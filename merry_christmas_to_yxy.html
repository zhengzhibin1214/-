<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å²³æ¬£å®œ(å®á´—å®)çš„åœ£è¯æ ‘ğŸ„</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: #ff69b4;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 10px;
            pointer-events: none;
        }
        h1 {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.7);
        }
        .instructions {
            color: #aaa;
            font-size: 14px;
            margin-top: 10px;
        }
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            display: none;
        }
        .mobile-btn {
            background: rgba(255, 105, 180, 0.7);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p style="color: #ff69b4; margin-top: 20px;">æ­£åœ¨åŠ è½½æµªæ¼«ç²’å­å®‡å®™...</p >
    </div>

    <div id="container">
        <div id="ui">
            <h1>âœ¨ ç²‰è‰²ç²’å­åœ£è¯æ ‘ âœ¨</h1>
            <p class="instructions">ç½‘é¡µç‰ˆï¼šæŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | æŒ‰ R é”®é‡ç½®</p >
            <p class="instructions">è§¦å±ç‰ˆï¼šç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ‡æ¢</p >
        </div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-switch">åˆ‡æ¢ä¸ºçˆ±å¿ƒ</button>
            <button class="mobile-btn" id="btn-reset">é‡ç½®åœ£è¯æ ‘</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <script>
        // ==================== é…ç½®ä¸çŠ¶æ€ ====================
        const CONFIG = {
            particleCount: 1200,
            particleColor: 0xFF69B4,
            backgroundColor: 0x000000,
            trunkColor: 0x8B4513,       // æ ‘å¹²é¢œè‰² - æ·±æ£•è‰²
            trunkHeight: 2.5,           // æ ‘å¹²é«˜åº¦
            trunkRadius: 0.4,           // æ ‘å¹²åŠå¾„
            trunkParticleCount: 80      // æ ‘å¹²ç²’å­æ•°
        };
        
        let scene, camera, renderer, particles, trunk, isTree = true;
        let treeParticles = [], heartParticles = [];
        
        // ==================== ä¸»åˆå§‹åŒ–å‡½æ•° ====================
        async function init() {
            const loadingScreen = document.getElementById('loading-screen');
            
            // æ£€æµ‹è®¾å¤‡å’Œäº¤äº’æ–¹å¼
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
                document.querySelector('.instructions').innerText = 'è§¦å±ç‰ˆï¼šç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ‡æ¢å½¢çŠ¶';
            }
            
            // åˆ›å»ºThree.jsåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.backgroundColor);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;
            camera.position.y = 3;
            
            // åˆ›å»ºæ¸²æŸ“å™¨ï¼ˆé’ˆå¯¹å¾®ä¿¡ä¼˜åŒ–ï¼‰
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff69b4, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // ç”Ÿæˆç²’å­æ•°æ®
            generateParticleData();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();
            
            // åˆ›å»ºæ ‘å¹²
            createTrunk();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // è®¾ç½®äº¤äº’
            setupInteractions();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1000);
            }, 1500);
            
            console.log('ğŸ„ ç²’å­åœ£è¯æ ‘åˆå§‹åŒ–å®Œæˆï¼æ¨¡å¼:', isMobile ? 'ç§»åŠ¨è§¦å±' : 'æ¡Œé¢é”®ç›˜');
        }
        
        // ==================== ç”Ÿæˆç²’å­æ•°æ® ====================
        function generateParticleData() {
            // ç”Ÿæˆåœ£è¯æ ‘ç²’å­
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const radius = Math.random() * 2.2;
                const angle = Math.random() * Math.PI * 2;
                const height = Math.random() * 5;
                const effectiveRadius = radius * (1 - height / 5);
                
                treeParticles.push(
                    Math.cos(angle) * effectiveRadius,
                    height,
                    Math.sin(angle) * effectiveRadius
                );
            }
            
            // ç”Ÿæˆçˆ±å¿ƒç²’å­
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const t = Math.random() * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 1.5;
                
                heartParticles.push(
                    x * 0.04,
                    y * 0.04 + 3,
                    z
                );
            }
        }
        
        // ==================== åˆ›å»ºæ ‘å† ç²’å­ç³»ç»Ÿ ====================
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(treeParticles, 3));
            
            const material = new THREE.PointsMaterial({
                color: CONFIG.particleColor,
                size: 0.08,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        // ==================== åˆ›å»ºæ ‘å¹²ç²’å­ç³»ç»Ÿ ====================
        function createTrunk() {
            const trunkGeometry = new THREE.BufferGeometry();
            const trunkPositions = [];
            
            // ç”Ÿæˆæ ‘å¹²ç²’å­ï¼ˆä¸€ä¸ªçŸ®åœ†æŸ±ä½“ï¼‰
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * CONFIG.trunkHeight;
                
                trunkPositions.push(
                    Math.cos(angle) * CONFIG.trunkRadius,
                    height - 2.5,
                    Math.sin(angle) * CONFIG.trunkRadius
                );
            }
            
            trunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trunkPositions, 3));
            
            const trunkMaterial = new THREE.PointsMaterial({
                color: CONFIG.trunkColor,
                size: 0.12,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });
            
            trunk = new THREE.Points(trunkGeometry, trunkMaterial);
            scene.add(trunk);
            
            return trunk;
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            // æ ‘å† ç¼“æ…¢æ—‹è½¬
            particles.rotation.y += 0.005;
            particles.rotation.x = Math.sin(Date.now() * 0.001) * 0.05;
            
            // æ ‘å¹²åŒæ­¥æ—‹è½¬
            if (trunk) {
                trunk.rotation.y = particles.rotation.y;
                trunk.rotation.x = particles.rotation.x;
            }
            
            renderer.render(scene, camera);
        }
        
        // ==================== å½¢çŠ¶åˆ‡æ¢å‡½æ•° ====================
        function switchShape() {
            const positions = particles.geometry.attributes.position.array;
            const targetShape = isTree ? heartParticles : treeParticles;
            
            // å¹³æ»‘è¿‡æ¸¡åŠ¨ç”»
            const startPositions = [...positions];
            const startTime = Date.now();
            const duration = 1200;
            
            function transition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ç¼“åŠ¨å‡½æ•°
                const easeProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                for (let i = 0; i < positions.length; i++) {
                    positions[i] = startPositions[i] + (targetShape[i] - startPositions[i]) * easeProgress;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                if (progress < 1) {
                    requestAnimationFrame(transition);
                } else {
                    isTree = !isTree;
                    updateUI();
                }
            }
            
            transition();
        }
        
        // ==================== æ›´æ–°ç•Œé¢æ˜¾ç¤º ====================
        function updateUI() {
            const title = document.querySelector('h1');
            const btn = document.getElementById('btn-switch');
            
            if (isTree) {
                title.innerHTML = 'âœ¨ ç²‰è‰²ç²’å­åœ£è¯æ ‘ âœ¨';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºçˆ±å¿ƒ';
            } else {
                title.innerHTML = 'â¤ï¸ å®å®æˆ‘çˆ±ä½  â¤ï¸';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºåœ£è¯æ ‘';
            }
        }
        
        // ==================== è®¾ç½®äº¤äº’æ§åˆ¶ ====================
        function setupInteractions() {
            // é”®ç›˜æ§åˆ¶ (æ¡Œé¢ç«¯)
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyH') switchShape();
                if (e.code === 'KeyR') resetToTree();
            });
            
            // è§¦æ‘¸æŒ‰é’®æ§åˆ¶ (ç§»åŠ¨ç«¯)
            const switchBtn = document.getElementById('btn-switch');
            const resetBtn = document.getElementById('btn-reset');
            
            if (switchBtn) {
                switchBtn.addEventListener('click', switchShape);
                switchBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    switchShape();
                });
            }
            
            if (resetBtn) {
                resetBtn.addEventListener('click', resetToTree);
                resetBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    resetToTree();
                });
            }
            
            // è§¦æ‘¸æ»‘åŠ¨æ‰‹åŠ¿æ§åˆ¶
            let touchStartY = 0;
            window.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            window.addEventListener('touchend', (e) => {
                const touchEndY = e.changedTouches[0].clientY;
                const deltaY = touchEndY - touchStartY;
                
                if (Math.abs(deltaY) > 50) {
                    switchShape();
                }
            }, { passive: true });
        }
        
        // ==================== é‡ç½®ä¸ºåœ£è¯æ ‘ ====================
        function resetToTree() {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i++) {
                positions[i] = treeParticles[i];
            }
            particles.geometry.attributes.position.needsUpdate = true;
            isTree = true;
            updateUI();
        }
        
        // ==================== çª—å£å¤§å°è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

