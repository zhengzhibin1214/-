<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å²³æ¬£å®œ(å®á´—å®)çš„åœ£è¯æ ‘ğŸ„</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(180deg, #0a0a2a 0%, #1a1a3a 30%, #2a2a4a 100%);
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: #ff69b4;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 10px;
            pointer-events: none;
        }
        h1 {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.9);
        }
        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            display: none;
        }
        .mobile-btn {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(255, 105, 180, 0.6);
            transition: all 0.3s;
            font-weight: bold;
        }
        .mobile-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(255, 105, 180, 0.8);
        }
        #particle-count {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 10px;
        }
        #mode-indicator {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .mode-text {
            display: inline-block;
            background: rgba(255, 105, 180, 0.2);
            color: #ff69b4;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.5s;
        }
        #snow-control {
            position: absolute;
            top: 120px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .snow-text {
            display: inline-block;
            background: rgba(173, 216, 230, 0.2);
            color: #add8e6;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p style="color: #ff69b4; margin-top: 20px;">æ­£åœ¨å®šåˆ¶ä¸“å±åœ£è¯æ ‘â¤ï¸...</p>
    </div>

    <div id="container">
        <div id="ui">
            <h1>âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨</h1>
            <p class="instructions">ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | é¼ æ ‡/æ‰‹æŒ‡æ‹–åŠ¨æ—‹è½¬ | æŒ‰ S é”®åˆ‡æ¢é›ªèŠ±</p>
        </div>
        
        <div id="mode-indicator">
            <span class="mode-text" id="mode-text">åœ£è¯æ ‘æ¨¡å¼</span>
        </div>
        
        <div id="snow-control">
            <span class="snow-text" id="snow-text">é›ªèŠ±: å¼€å¯</span>
        </div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-switch">åˆ‡æ¢ä¸ºçˆ±å¿ƒ</button>
            <button class="mobile-btn" id="btn-snow">åˆ‡æ¢é›ªèŠ±</button>
        </div>
        
        <div id="particle-count">ç²’å­æ•°: 0</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            // èºæ—‹æ ‘å† é…ç½®
            spiralTurns: 5,               // èºæ—‹åœˆæ•°
            spiralLayers: 10,             // èºæ—‹å±‚æ•°ï¼ˆå³é«˜åº¦æ–¹å‘çš„åˆ†æ®µï¼‰
            particlesPerLayer: 220,       // æ¯å±‚ç²’å­æ•°
            
            // æ ‘å¹²å’Œæ ‘æ
            trunkParticleCount: 200,
            branchParticleCount: 300,
            
            // é›ªèŠ±å’Œé›ªåœ°é…ç½®
            snowParticleCount: 400,       // ç©ºä¸­é›ªèŠ±
            groundSnowParticleCount: 800, // åœ°é¢é›ªç²’å­
            snowColor: 0xF0F8FF,          // é›ªèŠ±é¢œè‰²ï¼ˆçˆ±ä¸½ä¸è“ï¼‰
            groundSnowColor: 0xFFFFFF,    // åœ°é¢é›ªé¢œè‰²ï¼ˆçº¯ç™½ï¼‰
            snowEnabled: true,
            
            // æ ‘å† é¢œè‰²ï¼ˆç²‰è‰²ç³»æ¸å˜ï¼‰
            crownBaseColor: 0xFF69B4,     // åº•éƒ¨é¢œè‰²ï¼ˆæ·±ç²‰ï¼‰
            crownTopColor: 0xFFB6C1,      // é¡¶éƒ¨é¢œè‰²ï¼ˆæµ…ç²‰ï¼‰
            
            // å…¶ä»–é¢œè‰²
            trunkColor: 0x8B4513,
            branchColor: 0xA0522D,
            heartBaseColor: 0xFFB6C1,
            
            // ç²’å­å¤§å°
            crownParticleSize: 0.07,
            trunkParticleSize: 0.09,
            branchParticleSize: 0.075,
            groundSnowSize: 0.12,
            
            // ä½ç½®è°ƒæ•´
            treeVerticalPosition: -1.5,   // é™ä½åœ£è¯æ ‘ä½ç½®ï¼ˆè´Ÿæ•°è¡¨ç¤ºå‘ä¸‹ï¼‰
            groundSnowHeight: -3.5,       // é›ªåœ°é«˜åº¦
            groundSnowRadius: 8,          // é›ªåœ°åŠå¾„
            
            // åŠ¨ç”»
            rotationSpeed: 0.001,
            floatAmplitude: 0.015,
            floatSpeed: 0.0004,
            
            // è¿‡æ¸¡é…ç½®
            transitionDuration: 2000,
            colorTransitionDelay: 300
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let crownParticles, trunkParticles, branchParticles, snowParticles, groundSnowParticles;
        let crownGeometry, trunkGeometry, branchGeometry, snowGeometry, groundSnowGeometry;
        let crownMaterial, trunkMaterial, branchMaterial, snowMaterial, groundSnowMaterial;
        
        // ç²’å­ä½ç½®å’Œé¢œè‰²æ•°ç»„
        let crownTreePositions = [], crownHeartPositions = [];
        let crownTreeColors = [], crownHeartColors = [];
        let trunkTreePositions = [], trunkHeartPositions = [];
        let branchTreePositions = [], branchHeartPositions = [];
        let snowPositions = [], snowVelocities = [];
        let groundSnowPositions = [];
        
        // é¢œè‰²æ•°ç»„
        let trunkTreeColors = [], trunkHeartColors = [];
        let branchTreeColors = [], branchHeartColors = [];
        
        let isTree = true;
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let transitionInProgress = false;
        let snowEnabled = CONFIG.snowEnabled;
        
        // ==================== ä¸»åˆå§‹åŒ– ====================
        async function init() {
            const loadingScreen = document.getElementById('loading-screen');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
                document.querySelector('.instructions').textContent = 'ç‚¹å‡»æŒ‰é’®åˆ‡æ¢æ¨¡å¼ | æ‹–åŠ¨æ—‹è½¬';
            }
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a2a);
            
            // åˆ›å»ºç›¸æœº - æ–œä¸Šæ–¹45åº¦è§†è§’
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            // ç›¸æœºä½ç½®ï¼šxå’Œzåç§»ï¼Œyè¾ƒé«˜ï¼Œå½¢æˆ45åº¦ä¿¯è§’
            camera.position.set(12, 8, 12);  // æ–œä¸Šæ–¹45åº¦
            camera.lookAt(0, CONFIG.treeVerticalPosition + 2, 0); // çœ‹å‘åœ£è¯æ ‘ä¸­å¿ƒ
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // ä¸»å…‰æºï¼ˆç²‰è‰²ï¼Œä»æ–œä¸Šæ–¹ç…§å°„ï¼‰
            const mainLight = new THREE.DirectionalLight(0xff69b4, 0.8);
            mainLight.position.set(10, 15, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            // è¾…åŠ©å…‰æºï¼ˆç™½è‰²ï¼Œä»å¦ä¸€ä¾§è¡¥å…‰ï¼‰
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);
            
            // é›ªåœ°ä¸“ç”¨å…‰æº
            const snowLight = new THREE.DirectionalLight(0xadd8e6, 0.5);
            snowLight.position.set(5, 10, -5);
            scene.add(snowLight);
            
            // ç”Ÿæˆç²’å­æ•°æ®
            generateParticleData();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystems();
            
            // è®¾ç½®äº¤äº’
            setupInteractions();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 800);
            }, 1200);
            
            console.log('ğŸ„ èºæ—‹åœ£è¯æ ‘ä¸é›ªåœ°æ•ˆæœåˆå§‹åŒ–å®Œæˆï¼');
        }
        
        // ==================== ç”Ÿæˆç²’å­æ•°æ® ====================
        function generateParticleData() {
            // æ¸…ç©ºæ•°ç»„
            crownTreePositions = []; crownHeartPositions = [];
            crownTreeColors = []; crownHeartColors = [];
            trunkTreePositions = []; trunkHeartPositions = [];
            branchTreePositions = []; branchHeartPositions = [];
            trunkTreeColors = []; trunkHeartColors = [];
            branchTreeColors = []; branchHeartColors = [];
            snowPositions = []; snowVelocities = [];
            groundSnowPositions = [];
            
            // 1. ç”Ÿæˆèºæ—‹åœ£è¯æ ‘å† ç²’å­
            console.log(`ç”Ÿæˆèºæ—‹æ ‘å† ç²’å­...`);
            const totalParticles = CONFIG.spiralLayers * CONFIG.particlesPerLayer;
            
            for (let layer = 0; layer < CONFIG.spiralLayers; layer++) {
                // è®¡ç®—å½“å‰å±‚çš„é«˜åº¦ï¼ˆä»ä¸‹åˆ°ä¸Šï¼Œå±‚é—´éš”è¾ƒå¤§ï¼‰
                const height = layer * 0.9; // æ¯å±‚é«˜åº¦0.9å•ä½ï¼Œé—´éš”è¾ƒå¤§
                
                // è®¡ç®—å½“å‰å±‚çš„åŠå¾„ï¼ˆåº•éƒ¨å¤§ï¼Œé¡¶éƒ¨å°ï¼‰
                const maxRadius = 3.5 * (1 - layer / CONFIG.spiralLayers * 0.5);
                
                for (let i = 0; i < CONFIG.particlesPerLayer; i++) {
                    // è®¡ç®—èºæ—‹è§’åº¦ï¼ˆéšç€å±‚æ•°å¢åŠ è€Œæ—‹è½¬ï¼‰
                    const angle = (i / CONFIG.particlesPerLayer) * Math.PI * 2 + 
                                  (layer / CONFIG.spiralLayers) * CONFIG.spiralTurns * Math.PI * 2;
                    
                    // è®¡ç®—åŠå¾„ï¼ˆèºæ—‹å‘å¤–ï¼‰
                    const radius = maxRadius * (0.3 + 0.7 * (layer / CONFIG.spiralLayers));
                    
                    // æ·»åŠ ä¸€äº›éšæœºåç§»ï¼Œä½¿æ ‘å† æ›´è‡ªç„¶
                    const randomOffset = (Math.random() - 0.5) * 0.2;
                    
                    const x = Math.cos(angle) * (radius + randomOffset);
                    const z = Math.sin(angle) * (radius + randomOffset);
                    const y = height + (Math.random() - 0.5) * 0.3; // é«˜åº¦ä¸Šç¨å¾®éšæœº
                    
                    // åº”ç”¨å‚ç›´ä½ç½®åç§»ï¼ˆé™ä½æ•´æ£µæ ‘ï¼‰
                    const verticalOffset = CONFIG.treeVerticalPosition;
                    
                    crownTreePositions.push(x, y + verticalOffset, z);
                    
                    // è®¡ç®—é¢œè‰²æ¸å˜ï¼ˆä»åº•éƒ¨çš„æ·±ç²‰è‰²åˆ°é¡¶éƒ¨çš„æµ…ç²‰è‰²ï¼‰
                    const colorProgress = layer / CONFIG.spiralLayers;
                    const r = (CONFIG.crownBaseColor >> 16 & 255) / 255;
                    const g = (CONFIG.crownBaseColor >> 8 & 255) / 255;
                    const b = (CONFIG.crownBaseColor & 255) / 255;
                    
                    const r2 = (CONFIG.crownTopColor >> 16 & 255) / 255;
                    const g2 = (CONFIG.crownTopColor >> 8 & 255) / 255;
                    const b2 = (CONFIG.crownTopColor & 255) / 255;
                    
                    crownTreeColors.push(
                        r + (r2 - r) * colorProgress,
                        g + (g2 - g) * colorProgress,
                        b + (b2 - b) * colorProgress
                    );
                }
            }
            
            // 2. ç”Ÿæˆçˆ±å¿ƒç²’å­
            console.log("ç”Ÿæˆçˆ±å¿ƒç²’å­...");
            for (let i = 0; i < totalParticles; i++) {
                const u = Math.random();
                const v = Math.random();
                const t = v * Math.PI * 2;
                const r = Math.sqrt(u) * 1.3;
                
                const x = 16 * Math.pow(Math.sin(t), 3) * r;
                const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * r;
                const z = (Math.random() - 0.5) * 2.5 * (1 - u);
                
                // çˆ±å¿ƒä¹Ÿé™ä½ä½ç½®
                crownHeartPositions.push(
                    x * 0.045,
                    y * 0.045 + CONFIG.treeVerticalPosition + 2,
                    z * 0.6
                );
                
                // çˆ±å¿ƒé¢œè‰²ï¼ˆç²‰è‰²ç³»ï¼‰
                crownHeartColors.push(
                    0.9 + Math.random() * 0.1,  // R
                    0.4 + Math.random() * 0.2,  // G
                    0.6 + Math.random() * 0.2   // B
                );
            }
            
            // 3. ç”Ÿæˆæ ‘å¹²ç²’å­ - åœ£è¯æ ‘å½¢çŠ¶
            console.log("ç”Ÿæˆæ ‘å¹²ç²’å­...");
            const trunkHeight = 5.0;
            
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const height = -2.0 + (Math.random() * trunkHeight);
                const normalizedHeight = (height + 2.0) / trunkHeight;
                const radius = 0.9 * (1 - normalizedHeight * 0.6);
                const angle = Math.random() * Math.PI * 2;
                
                // åº”ç”¨å‚ç›´ä½ç½®åç§»
                trunkTreePositions.push(
                    Math.cos(angle) * radius * 0.8,
                    height + CONFIG.treeVerticalPosition,
                    Math.sin(angle) * radius
                );
                
                // æ ‘å¹²é¢œè‰²ï¼ˆæ·±æ£•è‰²ï¼‰
                trunkTreeColors.push(
                    (CONFIG.trunkColor >> 16 & 255) / 255,
                    (CONFIG.trunkColor >> 8 & 255) / 255,
                    (CONFIG.trunkColor & 255) / 255
                );
            }
            
            // 4. ç”Ÿæˆæ ‘å¹²ç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆåœ†å½¢åº•åº§ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒåº•åº§ç²’å­...");
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 2.5 * (0.5 + Math.random() * 0.5);
                const y = -1.5;
                
                trunkHeartPositions.push(
                    Math.cos(angle) * radius,
                    y + CONFIG.treeVerticalPosition + 1,
                    Math.sin(angle) * radius
                );
                
                // åº•åº§é¢œè‰²ï¼ˆæµ…ç²‰è‰²ï¼‰
                trunkHeartColors.push(
                    (CONFIG.heartBaseColor >> 16 & 255) / 255,
                    (CONFIG.heartBaseColor >> 8 & 255) / 255,
                    (CONFIG.heartBaseColor & 255) / 255
                );
            }
            
            // 5. ç”Ÿæˆæ ‘æç²’å­ - åœ£è¯æ ‘å½¢çŠ¶ï¼ˆä»èºæ—‹æ ‘å† ä¼¸å‡ºï¼‰
            console.log("ç”Ÿæˆæ ‘æç²’å­...");
            const branchLevels = [0.5, 2.0, 3.5, 5.0, 6.5];
            
            for (let level = 0; level < branchLevels.length; level++) {
                const levelHeight = branchLevels[level];
                const branchCount = 6 + level; // è¶Šå¾€ä¸Šåˆ†æ”¯è¶Šå¤š
                
                for (let branch = 0; branch < branchCount; branch++) {
                    const angle = (branch / branchCount) * Math.PI * 2 + Math.random() * 0.5;
                    const branchLength = 1.0 + Math.random() * 1.2 + level * 0.3;
                    const particlesPerBranch = Math.floor(CONFIG.branchParticleCount / (branchLevels.length * branchCount));
                    
                    for (let p = 0; p < particlesPerBranch; p++) {
                        const t = Math.random();
                        const curve = Math.sin(t * Math.PI) * 0.3;
                        const radius = 0.5 + branchLength * t;
                        const height = levelHeight - t * 0.5 + curve;
                        const jitter = (Math.random() - 0.5) * 0.3;
                        
                        // åº”ç”¨å‚ç›´ä½ç½®åç§»
                        branchTreePositions.push(
                            Math.cos(angle + curve) * radius + jitter,
                            height + CONFIG.treeVerticalPosition,
                            Math.sin(angle + curve) * radius + jitter
                        );
                        
                        // æ ‘æé¢œè‰²ï¼ˆèµ­è‰²ï¼‰
                        branchTreeColors.push(
                            (CONFIG.branchColor >> 16 & 255) / 255,
                            (CONFIG.branchColor >> 8 & 255) / 255,
                            (CONFIG.branchColor & 255) / 255
                        );
                    }
                }
            }
            
            // 6. ç”Ÿæˆæ ‘æç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆè£…é¥°ç²’å­ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒè£…é¥°ç²’å­...");
            for (let i = 0; i < CONFIG.branchParticleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 2.0 + Math.random() * 2.0;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta) + 1.0;
                const z = radius * Math.cos(phi);
                
                branchHeartPositions.push(
                    x * 0.4,
                    y * 0.4 + CONFIG.treeVerticalPosition + 1.5,
                    z * 0.4
                );
                
                // è£…é¥°ç²’å­é¢œè‰²ï¼ˆç²‰è‰²æ¸å˜ï¼‰
                const pinkValue = 0.8 + Math.random() * 0.2;
                branchHeartColors.push(
                    pinkValue,
                    pinkValue * 0.6,
                    pinkValue * 0.8
                );
            }
            
            // 7. ç”Ÿæˆç©ºä¸­é›ªèŠ±ç²’å­
            console.log(`ç”Ÿæˆ${CONFIG.snowParticleCount}ä¸ªé›ªèŠ±ç²’å­...`);
            const snowArea = 30;
            
            for (let i = 0; i < CONFIG.snowParticleCount; i++) {
                const x = (Math.random() - 0.5) * snowArea;
                const y = Math.random() * snowArea + 5;
                const z = (Math.random() - 0.5) * snowArea;
                
                snowPositions.push(x, y, z);
                
                snowVelocities.push(
                    (Math.random() - 0.5) * 0.015,
                    -0.4 * (0.5 + Math.random() * 0.5),
                    (Math.random() - 0.5) * 0.015
                );
            }
            
            // 8. ç”Ÿæˆåœ°é¢é›ªç²’å­
            console.log(`ç”Ÿæˆ${CONFIG.groundSnowParticleCount}ä¸ªåœ°é¢é›ªç²’å­...`);
            for (let i = 0; i < CONFIG.groundSnowParticleCount; i++) {
                // åœ¨åœ†å½¢åŒºåŸŸå†…ç”Ÿæˆ
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.sqrt(Math.random()) * CONFIG.groundSnowRadius;
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // é«˜åº¦æœ‰è½»å¾®èµ·ä¼ï¼Œæ¨¡æ‹Ÿç§¯é›ª
                const y = CONFIG.groundSnowHeight + (Math.random() - 0.5) * 0.3;
                
                groundSnowPositions.push(x, y, z);
            }
            
            console.log("ç²’å­æ•°æ®ç”Ÿæˆå®Œæˆ");
        }
        
        // ==================== åˆ›å»ºç²’å­ç³»ç»Ÿ ====================
        function createParticleSystems() {
            // 1. åˆ›å»ºæ ‘å† ç²’å­ç³»ç»Ÿï¼ˆå¸¦é¡¶ç‚¹é¢œè‰²ï¼‰
            crownGeometry = new THREE.BufferGeometry();
            crownGeometry.setAttribute('position', new THREE.Float32BufferAttribute(crownTreePositions, 3));
            crownGeometry.setAttribute('color', new THREE.Float32BufferAttribute(crownTreeColors, 3));
            
            crownMaterial = new THREE.PointsMaterial({
                size: CONFIG.crownParticleSize,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            crownParticles = new THREE.Points(crownGeometry, crownMaterial);
            scene.add(crownParticles);
            
            // 2. åˆ›å»ºæ ‘å¹²ç²’å­ç³»ç»Ÿï¼ˆå¸¦é¢œè‰²å±æ€§ï¼‰
            trunkGeometry = new THREE.BufferGeometry();
            trunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trunkTreePositions, 3));
            trunkGeometry.setAttribute('color', new THREE.Float32BufferAttribute(trunkTreeColors, 3));
            
            trunkMaterial = new THREE.PointsMaterial({
                size: CONFIG.trunkParticleSize,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            trunkParticles = new THREE.Points(trunkGeometry, trunkMaterial);
            scene.add(trunkParticles);
            
            // 3. åˆ›å»ºæ ‘æç²’å­ç³»ç»Ÿï¼ˆå¸¦é¢œè‰²å±æ€§ï¼‰
            branchGeometry = new THREE.BufferGeometry();
            branchGeometry.setAttribute('position', new THREE.Float32BufferAttribute(branchTreePositions, 3));
            branchGeometry.setAttribute('color', new THREE.Float32BufferAttribute(branchTreeColors, 3));
            
            branchMaterial = new THREE.PointsMaterial({
                size: CONFIG.branchParticleSize,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            branchParticles = new THREE.Points(branchGeometry, branchMaterial);
            scene.add(branchParticles);
            
            // 4. åˆ›å»ºç©ºä¸­é›ªèŠ±ç²’å­ç³»ç»Ÿ
            snowGeometry = new THREE.BufferGeometry();
            snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
            
            snowMaterial = new THREE.PointsMaterial({
                color: CONFIG.snowColor,
                size: CONFIG.crownParticleSize * 1.2,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            
            // 5. åˆ›å»ºåœ°é¢é›ªç²’å­ç³»ç»Ÿ
            groundSnowGeometry = new THREE.BufferGeometry();
            groundSnowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(groundSnowPositions, 3));
            
            groundSnowMaterial = new THREE.PointsMaterial({
                color: CONFIG.groundSnowColor,
                size: CONFIG.groundSnowSize,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });
            
            groundSnowParticles = new THREE.Points(groundSnowGeometry, groundSnowMaterial);
            scene.add(groundSnowParticles);
        }
        
        // ==================== ä¸æ»‘å½¢çŠ¶åˆ‡æ¢ ====================
        function switchShape() {
            if (transitionInProgress) return;
            transitionInProgress = true;
            
            const modeText = document.getElementById('mode-text');
            modeText.textContent = isTree ? "æ­£åœ¨åˆ‡æ¢åˆ°çˆ±å¿ƒ..." : "æ­£åœ¨åˆ‡æ¢å›åœ£è¯æ ‘...";
            modeText.style.background = "rgba(255, 105, 180, 0.4)";
            
            // è·å–å½“å‰ç²’å­ä½ç½®å’Œé¢œè‰²
            const crownPositions = crownGeometry.attributes.position.array;
            const crownColors = crownGeometry.attributes.color.array;
            const trunkPositions = trunkGeometry.attributes.position.array;
            const trunkColors = trunkGeometry.attributes.color.array;
            const branchPositions = branchGeometry.attributes.position.array;
            const branchColors = branchGeometry.attributes.color.array;
            
            // ç¡®å®šç›®æ ‡ä½ç½®å’Œé¢œè‰²
            const targetCrownPositions = isTree ? crownHeartPositions : crownTreePositions;
            const targetCrownColors = isTree ? crownHeartColors : crownTreeColors;
            const targetTrunkPositions = isTree ? trunkHeartPositions : trunkTreePositions;
            const targetTrunkColors = isTree ? trunkHeartColors : trunkTreeColors;
            const targetBranchPositions = isTree ? branchHeartPositions : branchTreePositions;
            const targetBranchColors = isTree ? branchHeartColors : branchTreeColors;
            
            // ä¿å­˜èµ·å§‹ä½ç½®å’Œé¢œè‰²
            const startCrownPositions = [...crownPositions];
            const startCrownColors = [...crownColors];
            const startTrunkPositions = [...trunkPositions];
            const startTrunkColors = [...trunkColors];
            const startBranchPositions = [...branchPositions];
            const startBranchColors = [...branchColors];
            
            const startTime = Date.now();
            const duration = CONFIG.transitionDuration;
            const colorDelay = CONFIG.colorTransitionDelay;
            
            // å¼€å§‹è¿‡æ¸¡åŠ¨ç”»
            function animateTransition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ä¸‰æ¬¡è´å¡å°”æ›²çº¿ç¼“åŠ¨å‡½æ•°
                const easeProgress = easeInOutCubic(progress);
                
                // è®¡ç®—é¢œè‰²è¿‡æ¸¡è¿›åº¦
                const colorProgress = Math.max(0, (elapsed - colorDelay) / (duration - colorDelay));
                const easeColorProgress = easeInOutCubic(Math.min(colorProgress, 1));
                
                // æ›´æ–°æ ‘å† ä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < crownPositions.length; i++) {
                    crownPositions[i] = startCrownPositions[i] + 
                        (targetCrownPositions[i] - startCrownPositions[i]) * easeProgress;
                    
                    if (i < targetCrownColors.length) {
                        crownColors[i] = startCrownColors[i] + 
                            (targetCrownColors[i] - startCrownColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°æ ‘å¹²ä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < trunkPositions.length; i++) {
                    trunkPositions[i] = startTrunkPositions[i] + 
                        (targetTrunkPositions[i] - startTrunkPositions[i]) * easeProgress;
                    
                    if (i < targetTrunkColors.length) {
                        trunkColors[i] = startTrunkColors[i] + 
                            (targetTrunkColors[i] - startTrunkColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°æ ‘æä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < branchPositions.length; i++) {
                    branchPositions[i] = startBranchPositions[i] + 
                        (targetBranchPositions[i] - startBranchPositions[i]) * easeProgress;
                    
                    if (i < targetBranchColors.length) {
                        branchColors[i] = startBranchColors[i] + 
                            (targetBranchColors[i] - startBranchColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°ç²’å­å¤§å°
                if (isTree) {
                    // åˆ‡æ¢åˆ°çˆ±å¿ƒæ—¶ï¼Œæ ‘å¹²ç²’å­å˜å¤§å½¢æˆåº•åº§
                    const sizeProgress = Math.min(elapsed / (duration * 0.7), 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize + 
                        (CONFIG.trunkParticleSize * 1.3 - CONFIG.trunkParticleSize) * sizeProgress;
                } else {
                    // åˆ‡æ¢å›åœ£è¯æ ‘æ—¶ï¼Œæ¢å¤åŸå¤§å°
                    const sizeProgress = Math.min(elapsed / (duration * 0.5), 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize * 1.3 + 
                        (CONFIG.trunkParticleSize - CONFIG.trunkParticleSize * 1.3) * sizeProgress;
                }
                
                // æ ‡è®°éœ€è¦æ›´æ–°
                crownGeometry.attributes.position.needsUpdate = true;
                crownGeometry.attributes.color.needsUpdate = true;
                trunkGeometry.attributes.position.needsUpdate = true;
                trunkGeometry.attributes.color.needsUpdate = true;
                branchGeometry.attributes.position.needsUpdate = true;
                branchGeometry.attributes.color.needsUpdate = true;
                trunkMaterial.needsUpdate = true;
                
                if (progress < 1) {
                    requestAnimationFrame(animateTransition);
                } else {
                    // è¿‡æ¸¡å®Œæˆ
                    isTree = !isTree;
                    transitionInProgress = false;
                    
                    // æ›´æ–°UI
                    updateUI();
                    
                    // ç¡®ä¿æœ€ç»ˆçŠ¶æ€æ­£ç¡®
                    trunkMaterial.size = isTree ? CONFIG.trunkParticleSize : CONFIG.trunkParticleSize * 1.3;
                    
                    console.log(`åˆ‡æ¢å®Œæˆ: ${isTree ? 'åœ£è¯æ ‘' : 'çˆ±å¿ƒ'}æ¨¡å¼`);
                }
            }
            
            animateTransition();
        }
        
        // ==================== åˆ‡æ¢é›ªèŠ±æ˜¾ç¤º ====================
        function toggleSnow() {
            snowEnabled = !snowEnabled;
            snowParticles.visible = snowEnabled;
            
            const snowText = document.getElementById('snow-text');
            snowText.textContent = `é›ªèŠ±: ${snowEnabled ? 'å¼€å¯' : 'å…³é—­'}`;
            snowText.style.background = snowEnabled ? "rgba(173, 216, 230, 0.3)" : "rgba(255, 255, 255, 0.1)";
            snowText.style.color = snowEnabled ? "#add8e6" : "rgba(255, 255, 255, 0.5)";
            
            console.log(`é›ªèŠ±æ•ˆæœ: ${snowEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
        }
        
        // ==================== ç¼“åŠ¨å‡½æ•° ====================
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * CONFIG.floatSpeed;
            
            if (!transitionInProgress) {
                // æ ¹æ®å½“å‰æ¨¡å¼è°ƒæ•´æ—‹è½¬é€Ÿåº¦
                const rotationSpeed = CONFIG.rotationSpeed * (isTree ? 1.0 : 0.7);
                
                // æ•´ä½“æ—‹è½¬ï¼ˆå—é¼ æ ‡æ§åˆ¶ï¼‰
                crownParticles.rotation.y += rotationSpeed + mouseX * 0.0006;
                crownParticles.rotation.x = Math.sin(time) * 0.01 + mouseY * 0.02;
                
                // æ ‘å† ç²’å­æµ®åŠ¨æ•ˆæœï¼ˆèºæ—‹æ ‘å† çš„ç‰¹æ®Šæ•ˆæœï¼‰
                const crownPositions = crownGeometry.attributes.position.array;
                const originalCrown = isTree ? crownTreePositions : crownHeartPositions;
                
                for (let i = 0; i < crownPositions.length; i += 3) {
                    const idx = i / 3;
                    const float1 = Math.sin(time * 0.5 + idx * 0.02) * CONFIG.floatAmplitude;
                    const float2 = Math.cos(time * 0.3 + idx * 0.01) * CONFIG.floatAmplitude * 0.7;
                    
                    // èºæ—‹æ ‘å† çš„æµ®åŠ¨æ•ˆæœï¼šä¸åŒé«˜åº¦æœ‰ä¸åŒå¹…åº¦
                    const heightFactor = originalCrown[i + 1] / 10 + 0.5;
                    
                    crownPositions[i] = originalCrown[i] + float1 * 0.1 * heightFactor + float2 * 0.05;
                    crownPositions[i + 1] = originalCrown[i + 1] + float1 * 0.8 * heightFactor;
                    crownPositions[i + 2] = originalCrown[i + 2] + float1 * 0.05 * heightFactor + float2 * 0.1;
                }
                
                crownGeometry.attributes.position.needsUpdate = true;
                
                // æ ‘å¹²å’Œæ ‘æè·Ÿéšæ—‹è½¬
                trunkParticles.rotation.y = crownParticles.rotation.y;
                trunkParticles.rotation.x = crownParticles.rotation.x;
                branchParticles.rotation.y = crownParticles.rotation.y;
                branchParticles.rotation.x = crownParticles.rotation.x;
            }
            
            // é›ªèŠ±åŠ¨ç”»
            if (snowEnabled && snowGeometry.attributes.position) {
                const snowPositions = snowGeometry.attributes.position.array;
                const snowArea = 30;
                const resetHeight = snowArea + 5;
                
                for (let i = 0; i < snowPositions.length; i += 3) {
                    const velocityIndex = i / 3 * 3;
                    
                    // æ›´æ–°ä½ç½®
                    snowPositions[i] += snowVelocities[velocityIndex];
                    snowPositions[i + 1] += snowVelocities[velocityIndex + 1];
                    snowPositions[i + 2] += snowVelocities[velocityIndex + 2];
                    
                    // æ·»åŠ è½»å¾®æ‘†åŠ¨
                    snowPositions[i] += Math.sin(time + i) * 0.0015;
                    snowPositions[i + 2] += Math.cos(time + i) * 0.0015;
                    
                    // å¦‚æœé›ªèŠ±è½åˆ°åœ°é¢ä»¥ä¸‹ï¼Œé‡ç½®åˆ°é¡¶éƒ¨
                    if (snowPositions[i + 1] < CONFIG.groundSnowHeight + 1) {
                        snowPositions[i] = (Math.random() - 0.5) * snowArea;
                        snowPositions[i + 1] = resetHeight;
                        snowPositions[i + 2] = (Math.random() - 0.5) * snowArea;
                    }
                }
                
                snowGeometry.attributes.position.needsUpdate = true;
            }
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }
        
        // ==================== æ›´æ–°ç•Œé¢ ====================
        function updateUI() {
            const title = document.querySelector('h1');
            const switchBtn = document.getElementById('btn-switch');
            const modeText = document.getElementById('mode-text');
            
            if (isTree) {
                title.innerHTML = 'âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨';
                if (switchBtn) switchBtn.textContent = 'åˆ‡æ¢ä¸ºçˆ±å¿ƒ';
                modeText.textContent = 'åœ£è¯æ ‘æ¨¡å¼';
                modeText.style.background = "rgba(255, 105, 180, 0.2)";
            } else {
                title.innerHTML = 'â¤ï¸ æˆ‘çˆ±ä½ å®å® â¤ï¸';
                if (switchBtn) switchBtn.textContent = 'åˆ‡æ¢ä¸ºåœ£è¯æ ‘';
                modeText.textContent = 'çˆ±å¿ƒæ¨¡å¼';
                modeText.style.background = "rgba(255, 182, 193, 0.3)";
            }
            
            updateParticleCount();
        }
        
        // ==================== æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º ====================
        function updateParticleCount() {
            const treeParticles = CONFIG.spiralLayers * CONFIG.particlesPerLayer + 
                                  CONFIG.trunkParticleCount + CONFIG.branchParticleCount;
            const snowParticles = snowEnabled ? CONFIG.snowParticleCount : 0;
            const totalParticles = treeParticles + snowParticles + CONFIG.groundSnowParticleCount;
            
            document.getElementById('particle-count').textContent = `ç²’å­æ•°: ${totalParticles.toLocaleString()}`;
        }
        
        // ==================== è®¾ç½®äº¤äº’ ====================
        function setupInteractions() {
            // é¼ æ ‡æ‹–åŠ¨æ§åˆ¶
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mouseX = (e.movementX / window.innerWidth) * 3;
                    mouseY = (e.movementY / window.innerHeight) * 3;
                } else {
                    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                }
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // è§¦æ‘¸æ§åˆ¶
            let touchStartX = 0, touchStartY = 0;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    e.preventDefault();
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    
                    mouseX = (touchX - touchStartX) / window.innerWidth * 6;
                    mouseY = (touchY - touchStartY) / window.innerHeight * 6;
                    
                    touchStartX = touchX;
                    touchStartY = touchY;
                    
                    e.preventDefault();
                }
            }, { passive: false });
            
            // é”®ç›˜æ§åˆ¶
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyH' || e.code === 'Space') {
                    switchShape();
                }
                if (e.code === 'KeyS') {
                    toggleSnow();
                }
            });
            
            // ç‚¹å‡»åˆ‡æ¢å½¢çŠ¶ï¼ˆä»…åœ¨éè¿‡æ¸¡çŠ¶æ€ï¼‰
            renderer.domElement.addEventListener('click', (e) => {
                if (e.target === renderer.domElement && !transitionInProgress) {
                    switchShape();
                }
            });
            
            // ç§»åŠ¨ç«¯æŒ‰é’®
            const switchBtn = document.getElementById('btn-switch');
            const snowBtn = document.getElementById('btn-snow');
            
            if (switchBtn) {
                switchBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!transitionInProgress) switchShape();
                });
                
                switchBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (!transitionInProgress) switchShape();
                }, { passive: false });
            }
            
            if (snowBtn) {
                snowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleSnow();
                });
                
                snowBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    toggleSnow();
                }, { passive: false });
            }
            
            // åŒå‡»é‡ç½®è§†è§’
            renderer.domElement.addEventListener('dblclick', () => {
                camera.position.set(12, 8, 12);
                camera.lookAt(0, CONFIG.treeVerticalPosition + 2, 0);
                mouseX = 0;
                mouseY = 0;
            });
        }
        
        // ==================== çª—å£å¤§å°è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>


