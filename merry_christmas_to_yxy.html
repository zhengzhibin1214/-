<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å²³æ¬£å®œ(å®á´—å®ï¼‰çš„åœ£è¯æ ‘ğŸ„</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0015, #1a0030);
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: #ff69b4;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 10px;
            pointer-events: none;
        }
        h1 {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 105, 180, 0.9);
        }
        .instructions {
            color: #aaa;
            font-size: 14px;
            margin-top: 5px;
        }
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            display: none;
        }
        .mobile-btn {
            background: rgba(255, 105, 180, 0.8);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(255, 105, 180, 0.6);
            transition: all 0.3s;
        }
        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(255, 105, 180, 1);
        }
        #particle-count {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p style="color: #ff69b4; margin-top: 20px;">æ­£åœ¨ç”Ÿæˆä¸“å±åœ£è¯æ ‘...</p>
    </div>

    <div id="container">
        <div id="ui">
            <h1>âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨</h1>
            <p class="instructions">ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | æŒ‰ R é”®é‡ç½®</p>
            <p class="instructions">é¼ æ ‡/æ‰‹æŒ‡ç§»åŠ¨å¯æ—‹è½¬è§†è§’</p>
        </div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-switch">åˆ‡æ¢ä¸ºçˆ±å¿ƒ</button>
            <button class="mobile-btn" id="btn-reset">é‡ç½®åœ£è¯æ ‘</button>
        </div>
        
        <div id="particle-count">ç²’å­æ•°: 0</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            // æ ‘å† ç²’å­
            crownParticleCount: 1500,
            crownColor: 0xFF69B4,
            
            // æ ‘å¹²ç²’å­
            trunkParticleCount: 120,
            trunkColor: 0x8B4513,
            
            // æ ‘æç²’å­
            branchParticleCount: 200,
            branchColor: 0xA0522D,
            
            // åœºæ™¯
            backgroundColor: 0x000000,
            ambientLightIntensity: 0.6,
            
            // åŠ¨ç”»
            rotationSpeed: 0.003,
            floatAmplitude: 0.03,
            floatSpeed: 0.001
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let crownParticles, trunkParticles, branchParticles;
        let crownGeometry, trunkGeometry, branchGeometry;
        let crownPositions = [], heartPositions = [];
        let trunkPositions = [], branchPositions = [];
        let trunkHeartPositions = [], branchHeartPositions = [];
        let isTree = true;
        let mouseX = 0, mouseY = 0;
        let animationId = null;
        
        // ==================== ä¸»åˆå§‹åŒ– ====================
        async function init() {
            const loadingScreen = document.getElementById('loading-screen');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
            }
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.backgroundColor);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;
            camera.position.y = 4;
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, CONFIG.ambientLightIntensity);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff69b4, 0.7);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // ç”Ÿæˆæ‰€æœ‰ç²’å­æ•°æ®
            generateAllParticleData();
            
            // åˆ›å»ºæ‰€æœ‰ç²’å­ç³»ç»Ÿ
            createParticleSystems();
            
            // æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º
            updateParticleCount();
            
            // è®¾ç½®äº¤äº’
            setupInteractions();
            
            // å¼€å§‹åŠ¨ç”»
            animate();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1000);
            }, 1200);
            
            console.log('ğŸ„ åœ£è¯æ ‘åˆå§‹åŒ–å®Œæˆï¼æ€»ç²’å­æ•°:', 
                CONFIG.crownParticleCount + CONFIG.trunkParticleCount + CONFIG.branchParticleCount);
        }
        
        // ==================== ç”Ÿæˆç²’å­æ•°æ® ====================
        function generateAllParticleData() {
            // æ¸…ç©ºæ•°ç»„
            crownPositions = []; heartPositions = [];
            trunkPositions = []; branchPositions = [];
            trunkHeartPositions = []; branchHeartPositions = [];
            
            // 1. ç”Ÿæˆæ ‘å† ç²’å­ï¼ˆåœ£è¯æ ‘å½¢çŠ¶ï¼‰
            for (let i = 0; i < CONFIG.crownParticleCount; i++) {
                // åˆ†å±‚ç”Ÿæˆï¼Œè¶Šå¾€ä¸Šè¶Šå°
                const layer = Math.floor(Math.random() * 5); // 0-4å±‚
                const layerHeight = layer * 1.0;
                const maxRadius = 3.5 - layer * 0.6;
                
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * maxRadius;
                const height = layerHeight + Math.random() * 0.8;
                
                // é”¥å½¢æ”¶ç¼©
                const effectiveRadius = radius * (1 - layer * 0.15);
                
                crownPositions.push(
                    Math.cos(angle) * effectiveRadius,
                    height,
                    Math.sin(angle) * effectiveRadius
                );
            }
            
            // 2. ç”Ÿæˆæ ‘å† ç²’å­ï¼ˆçˆ±å¿ƒå½¢çŠ¶ï¼‰
            for (let i = 0; i < CONFIG.crownParticleCount; i++) {
                const t = Math.random() * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 2.5; // å¢åŠ ä¸€äº›æ·±åº¦
                
                heartPositions.push(
                    x * 0.05,
                    y * 0.05 + 3.5,
                    z
                );
            }
            
            // 3. ç”Ÿæˆæ ‘å¹²ç²’å­ï¼ˆåœ£è¯æ ‘å½¢çŠ¶ï¼‰
            const trunkHeight = 4.5; // æ ‘å¹²é«˜åº¦
            const trunkBaseRadius = 0.8; // åº•éƒ¨åŠå¾„
            const trunkTopRadius = 0.4; // é¡¶éƒ¨åŠå¾„
            
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                // æ ‘å¹²ä»y=-2å¼€å§‹ï¼Œåˆ°y=2.5ç»“æŸï¼Œä¸æ ‘å† åº•éƒ¨è¡”æ¥
                const height = -2 + (Math.random() * trunkHeight); // -2 åˆ° 2.5
                const normalizedHeight = (height + 2) / trunkHeight; // 0åˆ°1
                
                // æ ‘å¹²åŠå¾„ä»ä¸‹åˆ°ä¸Šé€æ¸å˜å°
                const radius = trunkBaseRadius + (trunkTopRadius - trunkBaseRadius) * normalizedHeight;
                const angle = Math.random() * Math.PI * 2;
                
                trunkPositions.push(
                    Math.cos(angle) * radius * 0.8, // ç¨å¾®å‹æ‰ä¸€ç‚¹
                    height,
                    Math.sin(angle) * radius
                );
            }
            
            // 4. ç”Ÿæˆæ ‘å¹²ç²’å­ï¼ˆçˆ±å¿ƒå½¢çŠ¶ï¼‰- åœ¨çˆ±å¿ƒåº•éƒ¨å½¢æˆä¸€ä¸ªå°åº•åº§
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.3 + Math.random() * 0.2;
                const height = -1.5 + Math.random() * 1.0; // çˆ±å¿ƒåº•éƒ¨
                
                trunkHeartPositions.push(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
            }
            
            // 5. ç”Ÿæˆæ ‘æç²’å­ï¼ˆåœ£è¯æ ‘å½¢çŠ¶ï¼‰
            const branchLayers = [0.5, 1.5, 2.5]; // æ ‘ææ‰€åœ¨çš„å±‚é«˜
            for (let i = 0; i < CONFIG.branchParticleCount; i++) {
                const layerIndex = Math.floor(Math.random() * branchLayers.length);
                const layerHeight = branchLayers[layerIndex];
                
                // éšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å‘
                const angle = Math.random() * Math.PI * 2;
                const branchLength = 0.5 + Math.random() * 1.5;
                
                // ä»æ ‘å¹²å‘å¤–å»¶ä¼¸
                const startRadius = 0.5 + layerIndex * 0.3;
                const endRadius = startRadius + branchLength;
                
                // åœ¨æ ‘æä¸Šéšæœºå–ä¸€ä¸ªç‚¹
                const t = Math.random();
                const radius = startRadius + (endRadius - startRadius) * t;
                const branchAngle = angle + (Math.random() - 0.5) * 0.5; // ç¨å¾®æœ‰äº›å¼¯æ›²
                
                // é«˜åº¦ç¨å¾®å‘ä¸‹å€¾æ–œ
                const height = layerHeight - t * 0.3;
                
                branchPositions.push(
                    Math.cos(branchAngle) * radius,
                    height,
                    Math.sin(branchAngle) * radius
                );
            }
            
            // 6. ç”Ÿæˆæ ‘æç²’å­ï¼ˆçˆ±å¿ƒå½¢çŠ¶ï¼‰- åˆ†æ•£åœ¨çˆ±å¿ƒå‘¨å›´
            for (let i = 0; i < CONFIG.branchParticleCount; i++) {
                // éšæœºåˆ†å¸ƒåœ¨çˆ±å¿ƒå‘¨å›´çš„çƒå£³ä¸Š
                const radius = 1.5 + Math.random() * 2.0;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta) + 2;
                const z = radius * Math.cos(phi);
                
                branchHeartPositions.push(x * 0.5, y * 0.5, z * 0.5);
            }
        }
        
        // ==================== åˆ›å»ºç²’å­ç³»ç»Ÿ ====================
        function createParticleSystems() {
            // 1. åˆ›å»ºæ ‘å† ç²’å­ç³»ç»Ÿ
            crownGeometry = new THREE.BufferGeometry();
            crownGeometry.setAttribute('position', new THREE.Float32BufferAttribute(crownPositions, 3));
            
            const crownMaterial = new THREE.PointsMaterial({
                color: CONFIG.crownColor,
                size: 0.07,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            crownParticles = new THREE.Points(crownGeometry, crownMaterial);
            scene.add(crownParticles);
            
            // 2. åˆ›å»ºæ ‘å¹²ç²’å­ç³»ç»Ÿ
            trunkGeometry = new THREE.BufferGeometry();
            trunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trunkPositions, 3));
            
            const trunkMaterial = new THREE.PointsMaterial({
                color: CONFIG.trunkColor,
                size: 0.1,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true
            });
            
            trunkParticles = new THREE.Points(trunkGeometry, trunkMaterial);
            scene.add(trunkParticles);
            
            // 3. åˆ›å»ºæ ‘æç²’å­ç³»ç»Ÿ
            branchGeometry = new THREE.BufferGeometry();
            branchGeometry.setAttribute('position', new THREE.Float32BufferAttribute(branchPositions, 3));
            
            const branchMaterial = new THREE.PointsMaterial({
                color: CONFIG.branchColor,
                size: 0.08,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            branchParticles = new THREE.Points(branchGeometry, branchMaterial);
            scene.add(branchParticles);
        }
        
        // ==================== å½¢çŠ¶åˆ‡æ¢ ====================
        function switchShape() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            const crownPos = crownGeometry.attributes.position.array;
            const trunkPos = trunkGeometry.attributes.position.array;
            const branchPos = branchGeometry.attributes.position.array;
            
            const targetCrown = isTree ? heartPositions : crownPositions;
            const targetTrunk = isTree ? trunkHeartPositions : trunkPositions;
            const targetBranch = isTree ? branchHeartPositions : branchPositions;
            
            const startCrown = [...crownPos];
            const startTrunk = [...trunkPos];
            const startBranch = [...branchPos];
            
            const startTime = Date.now();
            const duration = 1500;
            
            function transition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                const easeProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // è¿‡æ¸¡æ ‘å† ç²’å­
                for (let i = 0; i < crownPos.length; i++) {
                    crownPos[i] = startCrown[i] + (targetCrown[i] - startCrown[i]) * easeProgress;
                }
                
                // è¿‡æ¸¡æ ‘å¹²ç²’å­
                for (let i = 0; i < trunkPos.length; i++) {
                    trunkPos[i] = startTrunk[i] + (targetTrunk[i] - startTrunk[i]) * easeProgress;
                }
                
                // è¿‡æ¸¡æ ‘æç²’å­
                for (let i = 0; i < branchPos.length; i++) {
                    branchPos[i] = startBranch[i] + (targetBranch[i] - startBranch[i]) * easeProgress;
                }
                
                crownGeometry.attributes.position.needsUpdate = true;
                trunkGeometry.attributes.position.needsUpdate = true;
                branchGeometry.attributes.position.needsUpdate = true;
                
                if (progress < 1) {
                    animationId = requestAnimationFrame(transition);
                } else {
                    isTree = !isTree;
                    updateUI();
                    animationId = null;
                }
            }
            
            animationId = requestAnimationFrame(transition);
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * CONFIG.floatSpeed;
            
            // æ ‘å† ç¼“æ…¢æ—‹è½¬å’Œæµ®åŠ¨
            crownParticles.rotation.y += CONFIG.rotationSpeed + mouseX * 0.002;
            crownParticles.rotation.x = Math.sin(time) * 0.05 + mouseY * 0.05;
            
            // æ·»åŠ æµ®åŠ¨æ•ˆæœ
            const positions = crownGeometry.attributes.position.array;
            const originalPositions = isTree ? crownPositions : heartPositions;
            
            for (let i = 0; i < positions.length; i += 3) {
                const idx = i / 3;
                const floatOffset = Math.sin(time + idx * 0.1) * CONFIG.floatAmplitude;
                
                positions[i] = originalPositions[i] + floatOffset * 0.5;     // X
                positions[i + 1] = originalPositions[i + 1] + floatOffset;   // Y
                positions[i + 2] = originalPositions[i + 2] + floatOffset * 0.3; // Z
            }
            
            crownGeometry.attributes.position.needsUpdate = true;
            
            // æ ‘å¹²å’Œæ ‘æè·Ÿéšæ—‹è½¬
            trunkParticles.rotation.y = crownParticles.rotation.y;
            trunkParticles.rotation.x = crownParticles.rotation.x;
            branchParticles.rotation.y = crownParticles.rotation.y;
            branchParticles.rotation.x = crownParticles.rotation.x;
            
            renderer.render(scene, camera);
        }
        
        // ==================== æ›´æ–°ç•Œé¢ ====================
        function updateUI() {
            const title = document.querySelector('h1');
            const btn = document.getElementById('btn-switch');
            const instructions = document.querySelectorAll('.instructions')[0];
            
            if (isTree) {
                title.innerHTML = 'âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºçˆ±å¿ƒ';
                instructions.textContent = 'ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | æŒ‰ R é”®é‡ç½®';
            } else {
                title.innerHTML = 'â¤ï¸ æˆ‘çˆ±ä½ å®å® â¤ï¸';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºåœ£è¯æ ‘';
                instructions.textContent = 'ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢åœ£è¯æ ‘ | æŒ‰ R é”®é‡ç½®';
            }
        }
        
        // ==================== æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º ====================
        function updateParticleCount() {
            const totalParticles = CONFIG.crownParticleCount + CONFIG.trunkParticleCount + CONFIG.branchParticleCount;
            document.getElementById('particle-count').textContent = `ç²’å­æ•°: ${totalParticles}`;
        }
        
        // ==================== è®¾ç½®äº¤äº’ ====================
        function setupInteractions() {
            // é¼ æ ‡ç§»åŠ¨æ§åˆ¶è§†è§’
            window.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            // è§¦æ‘¸æ§åˆ¶
            let touchStartX = 0, touchStartY = 0;
            window.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            window.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    mouseX = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                }
            }, { passive: true });
            
            // é”®ç›˜æ§åˆ¶
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyH') switchShape();
                if (e.code === 'KeyR') resetToTree();
            });
            
            // ç‚¹å‡»åˆ‡æ¢
            window.addEventListener('click', () => {
                if (!document.getElementById('loading-screen').style.display === 'none') {
                    switchShape();
                }
            });
            
            // ç§»åŠ¨ç«¯æŒ‰é’®
            const switchBtn = document.getElementById('btn-switch');
            const resetBtn = document.getElementById('btn-reset');
            
            if (switchBtn) {
                switchBtn.addEventListener('click', switchShape);
                switchBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    switchShape();
                });
            }
            
            if (resetBtn) {
                resetBtn.addEventListener('click', resetToTree);
                resetBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    resetToTree();
                });
            }
        }
        
        // ==================== é‡ç½®ä¸ºåœ£è¯æ ‘ ====================
        function resetToTree() {
            if (!isTree) {
                switchShape(); // å¦‚æœå½“å‰æ˜¯çˆ±å¿ƒï¼Œå…ˆåˆ‡æ¢å›åœ£è¯æ ‘
            }
            
            // é‡ç½®ä½ç½®
            const crownPos = crownGeometry.attributes.position.array;
            const trunkPos = trunkGeometry.attributes.position.array;
            const branchPos = branchGeometry.attributes.position.array;
            
            for (let i = 0; i < crownPos.length; i++) {
                crownPos[i] = crownPositions[i];
            }
            for (let i = 0; i < trunkPos.length; i++) {
                trunkPos[i] = trunkPositions[i];
            }
            for (let i = 0; i < branchPos.length; i++) {
                branchPos[i] = branchPositions[i];
            }
            
            crownGeometry.attributes.position.needsUpdate = true;
            trunkGeometry.attributes.position.needsUpdate = true;
            branchGeometry.attributes.position.needsUpdate = true;
            
            isTree = true;
            updateUI();
        }
        
        // ==================== çª—å£å¤§å°è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>


