<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å²³æ¬£å®œ(å®á´—å®)çš„åœ£è¯æ ‘ğŸ„</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #0a0015 100%);
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: #ff69b4;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 10px;
            pointer-events: none;
        }
        h1 {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.9);
        }
        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            display: none;
        }
        .mobile-btn {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(255, 105, 180, 0.6);
            transition: all 0.3s;
            font-weight: bold;
        }
        .mobile-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(255, 105, 180, 0.8);
        }
        #particle-count {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 10px;
        }
        #mode-indicator {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .mode-text {
            display: inline-block;
            background: rgba(255, 105, 180, 0.2);
            color: #ff69b4;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.5s;
        }
        #snow-control {
            position: absolute;
            top: 120px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .snow-text {
            display: inline-block;
            background: rgba(173, 216, 230, 0.2);
            color: #add8e6;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p style="color: #ff69b4; margin-top: 20px;">æ­£åœ¨å®šåˆ¶ä¸“å±åœ£è¯æ ‘â¤ï¸...</p>
    </div>

    <div id="container">
        <div id="ui">
            <h1>âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨</h1>
            <p class="instructions">ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | é¼ æ ‡/æ‰‹æŒ‡æ‹–åŠ¨æ—‹è½¬ | æŒ‰ S é”®åˆ‡æ¢é›ªèŠ±</p>
        </div>
        
        <div id="mode-indicator">
            <span class="mode-text" id="mode-text">åœ£è¯æ ‘æ¨¡å¼</span>
        </div>
        
        <div id="snow-control">
            <span class="snow-text" id="snow-text">é›ªèŠ±: å¼€å¯</span>
        </div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-switch">åˆ‡æ¢ä¸ºçˆ±å¿ƒ</button>
            <button class="mobile-btn" id="btn-snow">åˆ‡æ¢é›ªèŠ±</button>
        </div>
        
        <div id="particle-count">ç²’å­æ•°: 0</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            // åœ£è¯æ ‘ç²’å­æ•°é‡ï¼ˆå¢åŠ æ ‘å† å±‚æ•°ï¼‰
            crownParticleCount: 2200,      // å¢åŠ æ ‘å† ç²’å­
            trunkParticleCount: 180,
            branchParticleCount: 250,
            
            // é›ªèŠ±ç²’å­ç³»ç»Ÿ
            snowParticleCount: 500,        // é›ªèŠ±ç²’å­æ•°é‡
            snowColor: 0xE8F8FF,           // é›ªèŠ±é¢œè‰²ï¼ˆæ·¡è“è‰²ï¼‰
            snowSize: 0.08,                // é›ªèŠ±å¤§å°
            snowSpeed: 0.5,                // é›ªèŠ±ä¸‹è½é€Ÿåº¦
            snowEnabled: true,             // é»˜è®¤å¼€å¯é›ªèŠ±
            
            // åœ£è¯æ ‘é…ç½®
            treeLayers: 8,                 // å¢åŠ åˆ°8å±‚
            treeMaxRadius: 4.5,            // æœ€å¤§åŠå¾„å¢åŠ 
            
            // é¢œè‰²é…ç½®
            crownColor: 0xFF69B4,
            trunkColor: 0x8B4513,
            branchColor: 0xA0522D,
            heartBaseColor: 0xFFB6C1,
            
            // ç²’å­å¤§å°
            crownParticleSize: 0.06,
            trunkParticleSize: 0.08,
            branchParticleSize: 0.065,
            
            // åŠ¨ç”»
            rotationSpeed: 0.0012,
            floatAmplitude: 0.016,
            floatSpeed: 0.0005,
            
            // åœ†å½¢åº•åº§é…ç½®
            baseRadius: 3.2,
            baseHeight: -2.0,
            baseParticleSize: 0.085,
            
            // è¿‡æ¸¡é…ç½®
            transitionDuration: 2000,
            colorTransitionDelay: 300
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let crownParticles, trunkParticles, branchParticles, snowParticles;
        let crownGeometry, trunkGeometry, branchGeometry, snowGeometry;
        let crownMaterial, trunkMaterial, branchMaterial, snowMaterial;
        
        // ç²’å­ä½ç½®æ•°ç»„
        let crownTreePositions = [], crownHeartPositions = [];
        let trunkTreePositions = [], trunkHeartPositions = [];
        let branchTreePositions = [], branchHeartPositions = [];
        let snowPositions = [], snowVelocities = [];
        
        // é¢œè‰²æ•°ç»„
        let trunkTreeColors = [], trunkHeartColors = [];
        let branchTreeColors = [], branchHeartColors = [];
        
        let isTree = true;
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let transitionInProgress = false;
        let snowEnabled = CONFIG.snowEnabled;
        
        // ==================== ä¸»åˆå§‹åŒ– ====================
        async function init() {
            const loadingScreen = document.getElementById('loading-screen');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
                document.querySelector('.instructions').textContent = 'ç‚¹å‡»æŒ‰é’®åˆ‡æ¢æ¨¡å¼ | æ‹–åŠ¨æ—‹è½¬';
            }
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0015);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;  // ç¨å¾®æ‹‰è¿œä»¥æ˜¾ç¤ºæ›´å¤šé›ªèŠ±
            camera.position.y = 1.5;
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff69b4, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // æ·»åŠ ä¸€ä¸ªä¸“é—¨ç…§äº®é›ªèŠ±çš„å…‰æº
            const snowLight = new THREE.DirectionalLight(0xadd8e6, 0.3);
            snowLight.position.set(-5, 10, -5);
            scene.add(snowLight);
            
            // ç”Ÿæˆç²’å­æ•°æ®
            generateParticleData();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystems();
            
            // è®¾ç½®äº¤äº’
            setupInteractions();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 800);
            }, 1200);
            
            console.log('â„ï¸ é›ªèŠ±ç‰ˆå¤šå±‚åœ£è¯æ ‘åˆå§‹åŒ–å®Œæˆï¼');
        }
        
        // ==================== ç”Ÿæˆç²’å­æ•°æ® ====================
        function generateParticleData() {
            // æ¸…ç©ºæ•°ç»„
            crownTreePositions = []; crownHeartPositions = [];
            trunkTreePositions = []; trunkHeartPositions = [];
            branchTreePositions = []; branchHeartPositions = [];
            trunkTreeColors = []; trunkHeartColors = [];
            branchTreeColors = []; branchHeartColors = [];
            snowPositions = []; snowVelocities = [];
            
            // 1. ç”Ÿæˆå¤šå±‚åœ£è¯æ ‘å† ç²’å­
            console.log(`ç”Ÿæˆ${CONFIG.treeLayers}å±‚åœ£è¯æ ‘å† ç²’å­...`);
            for (let layer = 0; layer < CONFIG.treeLayers; layer++) {
                // æ¯å±‚ç²’å­æ•°éšå±‚æ•°å˜åŒ–ï¼Œä¸‹å±‚å¤šä¸Šå±‚å°‘
                const layerRatio = (CONFIG.treeLayers - layer) / CONFIG.treeLayers;
                const layerParticles = Math.floor(CONFIG.crownParticleCount * layerRatio / CONFIG.treeLayers * 1.5);
                
                const layerHeight = layer * 0.75;  // é™ä½æ¯å±‚é«˜åº¦ï¼Œä½¿æ ‘æ›´ç´§å‡‘
                const layerRadius = CONFIG.treeMaxRadius * (1 - layer * 0.08);
                
                for (let i = 0; i < layerParticles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.sqrt(Math.random()) * layerRadius;
                    const effectiveRadius = radius * (1 - layer * 0.1);
                    const height = layerHeight + Math.random() * 0.5;
                    
                    crownTreePositions.push(
                        Math.cos(angle) * effectiveRadius,
                        height,
                        Math.sin(angle) * effectiveRadius
                    );
                }
            }
            
            // 2. ç”Ÿæˆçˆ±å¿ƒç²’å­
            console.log("ç”Ÿæˆçˆ±å¿ƒç²’å­...");
            for (let i = 0; i < CONFIG.crownParticleCount; i++) {
                const u = Math.random();
                const v = Math.random();
                const t = v * Math.PI * 2;
                const r = Math.sqrt(u) * 1.2;
                
                const x = 16 * Math.pow(Math.sin(t), 3) * r;
                const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * r;
                const z = (Math.random() - 0.5) * 2.0 * (1 - u);
                
                crownHeartPositions.push(
                    x * 0.048,
                    y * 0.048 + 0.8,
                    z * 0.6
                );
            }
            
            // 3. ç”Ÿæˆæ ‘å¹²ç²’å­ - åœ£è¯æ ‘å½¢çŠ¶
            console.log("ç”Ÿæˆæ ‘å¹²ç²’å­...");
            const trunkHeight = 4.5;  // å¢åŠ æ ‘å¹²é«˜åº¦ä»¥åŒ¹é…æ›´å¤šå±‚æ ‘å† 
            
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const height = -2.5 + (Math.random() * trunkHeight);
                const normalizedHeight = (height + 2.5) / trunkHeight;
                const radius = 0.85 * (1 - normalizedHeight * 0.5);
                const angle = Math.random() * Math.PI * 2;
                
                trunkTreePositions.push(
                    Math.cos(angle) * radius * 0.7,
                    height,
                    Math.sin(angle) * radius
                );
                
                // æ ‘å¹²é¢œè‰²ï¼ˆæ·±æ£•è‰²ï¼‰
                trunkTreeColors.push(
                    (CONFIG.trunkColor >> 16 & 255) / 255,
                    (CONFIG.trunkColor >> 8 & 255) / 255,
                    (CONFIG.trunkColor & 255) / 255
                );
            }
            
            // 4. ç”Ÿæˆæ ‘å¹²ç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆåœ†å½¢åº•åº§ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒåº•åº§ç²’å­...");
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = CONFIG.baseRadius * (0.6 + Math.random() * 0.4);
                const y = CONFIG.baseHeight;
                
                trunkHeartPositions.push(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                
                // åº•åº§é¢œè‰²ï¼ˆæµ…ç²‰è‰²ï¼‰
                trunkHeartColors.push(
                    (CONFIG.heartBaseColor >> 16 & 255) / 255,
                    (CONFIG.heartBaseColor >> 8 & 255) / 255,
                    (CONFIG.heartBaseColor & 255) / 255
                );
            }
            
            // 5. ç”Ÿæˆæ ‘æç²’å­ - åœ£è¯æ ‘å½¢çŠ¶ï¼ˆæ›´å¤šåˆ†æ”¯ï¼‰
            console.log("ç”Ÿæˆæ ‘æç²’å­...");
            // å¢åŠ æ ‘æå±‚æ•°ä»¥åŒ¹é…æ›´å¤šæ ‘å† å±‚
            const branchLayers = [-0.3, 0.8, 1.9, 3.0, 4.1];
            const branchesPerLayer = 7;
            
            for (let layer = 0; layer < branchLayers.length; layer++) {
                const layerHeight = branchLayers[layer];
                
                for (let branch = 0; branch < branchesPerLayer; branch++) {
                    const angle = (branch / branchesPerLayer) * Math.PI * 2 + Math.random() * 0.3;
                    const branchLength = 1.2 + Math.random() * 1.3;
                    const particlesPerBranch = Math.floor(CONFIG.branchParticleCount / (branchLayers.length * branchesPerLayer));
                    
                    for (let p = 0; p < particlesPerBranch; p++) {
                        const t = Math.random();
                        const curve = Math.sin(t * Math.PI) * 0.2;
                        const radius = 0.6 + branchLength * t;
                        const height = layerHeight - t * 0.35 + curve;
                        const jitter = (Math.random() - 0.5) * 0.2;
                        
                        branchTreePositions.push(
                            Math.cos(angle + curve) * radius + jitter,
                            height,
                            Math.sin(angle + curve) * radius + jitter
                        );
                        
                        // æ ‘æé¢œè‰²ï¼ˆèµ­è‰²ï¼‰
                        branchTreeColors.push(
                            (CONFIG.branchColor >> 16 & 255) / 255,
                            (CONFIG.branchColor >> 8 & 255) / 255,
                            (CONFIG.branchColor & 255) / 255
                        );
                    }
                }
            }
            
            // 6. ç”Ÿæˆæ ‘æç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆè£…é¥°ç²’å­ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒè£…é¥°ç²’å­...");
            for (let i = 0; i < CONFIG.branchParticleCount; i++) {
                // åœ¨çˆ±å¿ƒå‘¨å›´å½¢æˆå…‰ç¯æ•ˆæœ
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 2.2 + Math.random() * 1.8;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta) + 0.5;
                const z = radius * Math.cos(phi);
                
                branchHeartPositions.push(
                    x * 0.35,
                    y * 0.35,
                    z * 0.35
                );
                
                // è£…é¥°ç²’å­é¢œè‰²ï¼ˆç²‰è‰²æ¸å˜ï¼‰
                const pinkValue = 0.8 + Math.random() * 0.2;
                branchHeartColors.push(
                    pinkValue,
                    pinkValue * 0.6,
                    pinkValue * 0.8
                );
            }
            
            // 7. ç”Ÿæˆé›ªèŠ±ç²’å­
            console.log(`ç”Ÿæˆ${CONFIG.snowParticleCount}ä¸ªé›ªèŠ±ç²’å­...`);
            const snowArea = 25; // é›ªèŠ±åˆ†å¸ƒåŒºåŸŸå¤§å°
            
            for (let i = 0; i < CONFIG.snowParticleCount; i++) {
                // éšæœºåˆ†å¸ƒåœ¨ç›¸æœºè§†é‡èŒƒå›´å†…
                const x = (Math.random() - 0.5) * snowArea;
                const y = Math.random() * snowArea + 5; // ä»ä¸Šæ–¹å¼€å§‹
                const z = (Math.random() - 0.5) * snowArea;
                
                snowPositions.push(x, y, z);
                
                // éšæœºé€Ÿåº¦
                snowVelocities.push(
                    (Math.random() - 0.5) * 0.02, // Xæ–¹å‘è½»å¾®æ¼‚ç§»
                    -CONFIG.snowSpeed * (0.5 + Math.random() * 0.5), // Yæ–¹å‘ä¸‹è½é€Ÿåº¦
                    (Math.random() - 0.5) * 0.02  // Zæ–¹å‘è½»å¾®æ¼‚ç§»
                );
            }
            
            console.log("ç²’å­æ•°æ®ç”Ÿæˆå®Œæˆ");
        }
        
        // ==================== åˆ›å»ºç²’å­ç³»ç»Ÿ ====================
        function createParticleSystems() {
            // 1. åˆ›å»ºæ ‘å† ç²’å­ç³»ç»Ÿ
            crownGeometry = new THREE.BufferGeometry();
            crownGeometry.setAttribute('position', new THREE.Float32BufferAttribute(crownTreePositions, 3));
            
            crownMaterial = new THREE.PointsMaterial({
                color: CONFIG.crownColor,
                size: CONFIG.crownParticleSize,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            crownParticles = new THREE.Points(crownGeometry, crownMaterial);
            scene.add(crownParticles);
            
            // 2. åˆ›å»ºæ ‘å¹²ç²’å­ç³»ç»Ÿï¼ˆå¸¦é¢œè‰²å±æ€§ï¼‰
            trunkGeometry = new THREE.BufferGeometry();
            trunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trunkTreePositions, 3));
            trunkGeometry.setAttribute('color', new THREE.Float32BufferAttribute(trunkTreeColors, 3));
            
            trunkMaterial = new THREE.PointsMaterial({
                size: CONFIG.trunkParticleSize,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            trunkParticles = new THREE.Points(trunkGeometry, trunkMaterial);
            scene.add(trunkParticles);
            
            // 3. åˆ›å»ºæ ‘æç²’å­ç³»ç»Ÿï¼ˆå¸¦é¢œè‰²å±æ€§ï¼‰
            branchGeometry = new THREE.BufferGeometry();
            branchGeometry.setAttribute('position', new THREE.Float32BufferAttribute(branchTreePositions, 3));
            branchGeometry.setAttribute('color', new THREE.Float32BufferAttribute(branchTreeColors, 3));
            
            branchMaterial = new THREE.PointsMaterial({
                size: CONFIG.branchParticleSize,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            branchParticles = new THREE.Points(branchGeometry, branchMaterial);
            scene.add(branchParticles);
            
            // 4. åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿ
            snowGeometry = new THREE.BufferGeometry();
            snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
            
            snowMaterial = new THREE.PointsMaterial({
                color: CONFIG.snowColor,
                size: CONFIG.snowSize,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
        }
        
        // ==================== ä¸æ»‘å½¢çŠ¶åˆ‡æ¢ ====================
        function switchShape() {
            if (transitionInProgress) return;
            transitionInProgress = true;
            
            const modeText = document.getElementById('mode-text');
            modeText.textContent = isTree ? "æ­£åœ¨åˆ‡æ¢åˆ°çˆ±å¿ƒ..." : "æ­£åœ¨åˆ‡æ¢å›åœ£è¯æ ‘...";
            modeText.style.background = "rgba(255, 105, 180, 0.4)";
            
            // è·å–å½“å‰ç²’å­ä½ç½®å’Œé¢œè‰²
            const crownPositions = crownGeometry.attributes.position.array;
            const trunkPositions = trunkGeometry.attributes.position.array;
            const trunkColors = trunkGeometry.attributes.color.array;
            const branchPositions = branchGeometry.attributes.position.array;
            const branchColors = branchGeometry.attributes.color.array;
            
            // ç¡®å®šç›®æ ‡ä½ç½®å’Œé¢œè‰²
            const targetCrownPositions = isTree ? crownHeartPositions : crownTreePositions;
            const targetTrunkPositions = isTree ? trunkHeartPositions : trunkTreePositions;
            const targetTrunkColors = isTree ? trunkHeartColors : trunkTreeColors;
            const targetBranchPositions = isTree ? branchHeartPositions : branchTreePositions;
            const targetBranchColors = isTree ? branchHeartColors : branchTreeColors;
            
            // ä¿å­˜èµ·å§‹ä½ç½®å’Œé¢œè‰²
            const startCrownPositions = [...crownPositions];
            const startTrunkPositions = [...trunkPositions];
            const startTrunkColors = [...trunkColors];
            const startBranchPositions = [...branchPositions];
            const startBranchColors = [...branchColors];
            
            const startTime = Date.now();
            const duration = CONFIG.transitionDuration;
            const colorDelay = CONFIG.colorTransitionDelay;
            
            // å¼€å§‹è¿‡æ¸¡åŠ¨ç”»
            function animateTransition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ä¸‰æ¬¡è´å¡å°”æ›²çº¿ç¼“åŠ¨å‡½æ•°
                const easeProgress = easeInOutCubic(progress);
                
                // è®¡ç®—é¢œè‰²è¿‡æ¸¡è¿›åº¦
                const colorProgress = Math.max(0, (elapsed - colorDelay) / (duration - colorDelay));
                const easeColorProgress = easeInOutCubic(Math.min(colorProgress, 1));
                
                // æ›´æ–°æ ‘å† ä½ç½®
                for (let i = 0; i < crownPositions.length; i++) {
                    crownPositions[i] = startCrownPositions[i] + 
                        (targetCrownPositions[i] - startCrownPositions[i]) * easeProgress;
                }
                
                // æ›´æ–°æ ‘å¹²ä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < trunkPositions.length; i++) {
                    // ä½ç½®è¿‡æ¸¡
                    trunkPositions[i] = startTrunkPositions[i] + 
                        (targetTrunkPositions[i] - startTrunkPositions[i]) * easeProgress;
                    
                    // é¢œè‰²è¿‡æ¸¡
                    if (i < targetTrunkColors.length) {
                        trunkColors[i] = startTrunkColors[i] + 
                            (targetTrunkColors[i] - startTrunkColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°æ ‘æä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < branchPositions.length; i++) {
                    // ä½ç½®è¿‡æ¸¡
                    branchPositions[i] = startBranchPositions[i] + 
                        (targetBranchPositions[i] - startBranchPositions[i]) * easeProgress;
                    
                    // é¢œè‰²è¿‡æ¸¡
                    if (i < targetBranchColors.length) {
                        branchColors[i] = startBranchColors[i] + 
                            (targetBranchColors[i] - startBranchColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°ç²’å­å¤§å°
                if (isTree) {
                    // åˆ‡æ¢åˆ°çˆ±å¿ƒæ—¶ï¼Œæ ‘å¹²ç²’å­å˜å¤§å½¢æˆåº•åº§
                    const sizeProgress = Math.min(elapsed / (duration * 0.8), 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize + 
                        (CONFIG.baseParticleSize - CONFIG.trunkParticleSize) * sizeProgress;
                } else {
                    // åˆ‡æ¢å›åœ£è¯æ ‘æ—¶ï¼Œæ¢å¤åŸå¤§å°
                    const sizeProgress = Math.min(elapsed / (duration * 0.6), 1);
                    trunkMaterial.size = CONFIG.baseParticleSize + 
                        (CONFIG.trunkParticleSize - CONFIG.baseParticleSize) * sizeProgress;
                }
                
                // æ ‡è®°éœ€è¦æ›´æ–°
                crownGeometry.attributes.position.needsUpdate = true;
                trunkGeometry.attributes.position.needsUpdate = true;
                trunkGeometry.attributes.color.needsUpdate = true;
                branchGeometry.attributes.position.needsUpdate = true;
                branchGeometry.attributes.color.needsUpdate = true;
                trunkMaterial.needsUpdate = true;
                
                if (progress < 1) {
                    requestAnimationFrame(animateTransition);
                } else {
                    // è¿‡æ¸¡å®Œæˆ
                    isTree = !isTree;
                    transitionInProgress = false;
                    
                    // æ›´æ–°UI
                    updateUI();
                    
                    // ç¡®ä¿æœ€ç»ˆçŠ¶æ€æ­£ç¡®
                    trunkMaterial.size = isTree ? CONFIG.trunkParticleSize : CONFIG.baseParticleSize;
                    
                    console.log(`åˆ‡æ¢å®Œæˆ: ${isTree ? 'åœ£è¯æ ‘' : 'çˆ±å¿ƒ'}æ¨¡å¼`);
                }
            }
            
            animateTransition();
        }
        
        // ==================== åˆ‡æ¢é›ªèŠ±æ˜¾ç¤º ====================
        function toggleSnow() {
            snowEnabled = !snowEnabled;
            snowParticles.visible = snowEnabled;
            
            const snowText = document.getElementById('snow-text');
            snowText.textContent = `é›ªèŠ±: ${snowEnabled ? 'å¼€å¯' : 'å…³é—­'}`;
            snowText.style.background = snowEnabled ? "rgba(173, 216, 230, 0.3)" : "rgba(255, 255, 255, 0.1)";
            snowText.style.color = snowEnabled ? "#add8e6" : "rgba(255, 255, 255, 0.5)";
            
            console.log(`é›ªèŠ±æ•ˆæœ: ${snowEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
        }
        
        // ==================== ç¼“åŠ¨å‡½æ•° ====================
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * CONFIG.floatSpeed;
            
            if (!transitionInProgress) {
                // æ ¹æ®å½“å‰æ¨¡å¼è°ƒæ•´æ—‹è½¬é€Ÿåº¦
                const rotationSpeed = CONFIG.rotationSpeed * (isTree ? 1.0 : 0.8);
                
                // æ•´ä½“æ—‹è½¬ï¼ˆå—é¼ æ ‡æ§åˆ¶ï¼‰
                crownParticles.rotation.y += rotationSpeed + mouseX * 0.0008;
                crownParticles.rotation.x = Math.sin(time) * 0.015 + mouseY * 0.025;
                
                // æ ‘å† ç²’å­æµ®åŠ¨æ•ˆæœ
                const crownPositions = crownGeometry.attributes.position.array;
                const originalCrown = isTree ? crownTreePositions : crownHeartPositions;
                
                for (let i = 0; i < crownPositions.length; i += 3) {
                    const idx = i / 3;
                    const float1 = Math.sin(time + idx * 0.03) * CONFIG.floatAmplitude;
                    const float2 = Math.cos(time * 0.5 + idx * 0.015) * CONFIG.floatAmplitude * 0.5;
                    
                    crownPositions[i] = originalCrown[i] + float1 * 0.15 + float2;
                    crownPositions[i + 1] = originalCrown[i + 1] + float1 * 0.7;
                    crownPositions[i + 2] = originalCrown[i + 2] + float1 * 0.1 + float2 * 0.25;
                }
                
                crownGeometry.attributes.position.needsUpdate = true;
                
                // æ ‘å¹²å’Œæ ‘æè·Ÿéšæ—‹è½¬
                trunkParticles.rotation.y = crownParticles.rotation.y;
                trunkParticles.rotation.x = crownParticles.rotation.x;
                branchParticles.rotation.y = crownParticles.rotation.y;
                branchParticles.rotation.x = crownParticles.rotation.x;
            }
            
            // é›ªèŠ±åŠ¨ç”»
            if (snowEnabled && snowGeometry.attributes.position) {
                const snowPositions = snowGeometry.attributes.position.array;
                const snowArea = 25;
                const resetHeight = snowArea + 5;
                
                for (let i = 0; i < snowPositions.length; i += 3) {
                    const velocityIndex = i / 3 * 3;
                    
                    // æ›´æ–°ä½ç½®
                    snowPositions[i] += snowVelocities[velocityIndex];
                    snowPositions[i + 1] += snowVelocities[velocityIndex + 1];
                    snowPositions[i + 2] += snowVelocities[velocityIndex + 2];
                    
                    // æ·»åŠ è½»å¾®æ‘†åŠ¨
                    snowPositions[i] += Math.sin(time + i) * 0.001;
                    snowPositions[i + 2] += Math.cos(time + i) * 0.001;
                    
                    // å¦‚æœé›ªèŠ±è½åˆ°ä¸‹æ–¹ï¼Œé‡ç½®åˆ°é¡¶éƒ¨
                    if (snowPositions[i + 1] < -10) {
                        snowPositions[i] = (Math.random() - 0.5) * snowArea;
                        snowPositions[i + 1] = resetHeight;
                        snowPositions[i + 2] = (Math.random() - 0.5) * snowArea;
                    }
                }
                
                snowGeometry.attributes.position.needsUpdate = true;
                
                // é›ªèŠ±è·Ÿéšç›¸æœºæ—‹è½¬ï¼ˆè½»å¾®ï¼‰
                snowParticles.rotation.y += 0.0001;
            }
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }
        
        // ==================== æ›´æ–°ç•Œé¢ ====================
        function updateUI() {
            const title = document.querySelector('h1');
            const switchBtn = document.getElementById('btn-switch');
            const modeText = document.getElementById('mode-text');
            
            if (isTree) {
                title.innerHTML = 'âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨';
                if (switchBtn) switchBtn.textContent = 'åˆ‡æ¢ä¸ºçˆ±å¿ƒ';
                modeText.textContent = 'åœ£è¯æ ‘æ¨¡å¼';
                modeText.style.background = "rgba(255, 105, 180, 0.2)";
            } else {
                title.innerHTML = 'â¤ï¸ æˆ‘çˆ±ä½ å®å® â¤ï¸';
                if (switchBtn) switchBtn.textContent = 'åˆ‡æ¢ä¸ºåœ£è¯æ ‘';
                modeText.textContent = 'çˆ±å¿ƒæ¨¡å¼';
                modeText.style.background = "rgba(255, 182, 193, 0.3)";
            }
            
            updateParticleCount();
        }
        
        // ==================== æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º ====================
        function updateParticleCount() {
            const totalParticles = CONFIG.crownParticleCount + CONFIG.trunkParticleCount + 
                                  CONFIG.branchParticleCount + (snowEnabled ? CONFIG.snowParticleCount : 0);
            document.getElementById('particle-count').textContent = `ç²’å­æ•°: ${totalParticles.toLocaleString()}`;
        }
        
        // ==================== è®¾ç½®äº¤äº’ ====================
        function setupInteractions() {
            // é¼ æ ‡æ‹–åŠ¨æ§åˆ¶
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mouseX = (e.movementX / window.innerWidth) * 4;
                    mouseY = (e.movementY / window.innerHeight) * 4;
                } else {
                    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                }
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // è§¦æ‘¸æ§åˆ¶
            let touchStartX = 0, touchStartY = 0;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    e.preventDefault();
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    
                    mouseX = (touchX - touchStartX) / window.innerWidth * 8;
                    mouseY = (touchY - touchStartY) / window.innerHeight * 8;
                    
                    touchStartX = touchX;
                    touchStartY = touchY;
                    
                    e.preventDefault();
                }
            }, { passive: false });
            
            // é”®ç›˜æ§åˆ¶
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyH' || e.code === 'Space') {
                    switchShape();
                }
                if (e.code === 'KeyS') {
                    toggleSnow();
                }
            });
            
            // ç‚¹å‡»åˆ‡æ¢å½¢çŠ¶ï¼ˆä»…åœ¨éè¿‡æ¸¡çŠ¶æ€ï¼‰
            renderer.domElement.addEventListener('click', (e) => {
                if (e.target === renderer.domElement && !transitionInProgress) {
                    switchShape();
                }
            });
            
            // ç§»åŠ¨ç«¯æŒ‰é’®
            const switchBtn = document.getElementById('btn-switch');
            const snowBtn = document.getElementById('btn-snow');
            
            if (switchBtn) {
                switchBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!transitionInProgress) switchShape();
                });
                
                switchBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (!transitionInProgress) switchShape();
                }, { passive: false });
            }
            
            if (snowBtn) {
                snowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleSnow();
                });
                
                snowBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    toggleSnow();
                }, { passive: false });
            }
            
            // åŒå‡»é‡ç½®è§†è§’
            renderer.domElement.addEventListener('dblclick', () => {
                camera.position.z = 15;
                camera.position.y = 1.5;
                camera.lookAt(0, 0, 0);
                mouseX = 0;
                mouseY = 0;
            });
        }
        
        // ==================== çª—å£å¤§å°è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>




