<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å²³æ¬£å®œ(å®á´—å®)çš„åœ£è¯æ ‘ğŸ„</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0015 0%, #1a0030 50%, #0a0015 100%);
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: #ff69b4;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 10px;
            pointer-events: none;
        }
        h1 {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.9);
        }
        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            display: none;
        }
        .mobile-btn {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(255, 105, 180, 0.6);
            transition: all 0.3s;
            font-weight: bold;
        }
        .mobile-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(255, 105, 180, 0.8);
        }
        #particle-count {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 10px;
        }
        #performance-warning {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p style="color: #ff69b4; margin-top: 20px;">å®šåˆ¶ä¸“å±åœ£è¯æ ‘ä¸­...</p>
    </div>

    <div id="container">
        <div id="ui">
            <h1>âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨</h1>
            <p class="instructions">ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | æŒ‰ R é”®é‡ç½®</p>
            <p class="instructions">é¼ æ ‡/æ‰‹æŒ‡ç§»åŠ¨å¯æ—‹è½¬è§†è§’</p>
        </div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-switch">åˆ‡æ¢ä¸ºçˆ±å¿ƒ</button>
            <button class="mobile-btn" id="btn-reset">é‡ç½®åœ£è¯æ ‘</button>
        </div>
        
        <div id="particle-count">ç²’å­æ•°: 0</div>
        <div id="performance-warning"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <script>
        // ==================== é«˜å¯†åº¦ç²’å­é…ç½® ====================
        const CONFIG = {
            crownParticleCount: 2500,
            trunkParticleCount: 200,
            branchParticleCount: 300,
            
            crownColor: 0xFF69B4,
            trunkColor: 0x8B4513,
            branchColor: 0xA0522D,
            
            crownParticleSize: 0.06,
            trunkParticleSize: 0.09,
            branchParticleSize: 0.07,
            
            backgroundColor: 0x000000,
            ambientLightIntensity: 0.7,
            
            rotationSpeed: 0.002,
            floatAmplitude: 0.02,
            floatSpeed: 0.0008,
            
            // æ–°é…ç½®ï¼šå‚ç›´åç§»é‡
            treeVerticalOffset: 1.5,    // åœ£è¯æ ‘ä¸Šç§»1.5ä¸ªå•ä½
            heartVerticalOffset: 0.8,   // çˆ±å¿ƒä¸Šç§»0.8ä¸ªå•ä½
            
            // åˆ‡æ¢åŠ¨ç”»é…ç½®
            trunkFadeOutDuration: 400,  // æ ‘å¹²æ·¡å‡ºæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
            branchFadeOutDuration: 500   // æ ‘ææ·¡å‡ºæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let crownParticles, trunkParticles, branchParticles;
        let crownGeometry, trunkGeometry, branchGeometry;
        let crownMaterial, trunkMaterial, branchMaterial;
        let crownPositions = [], heartPositions = [];
        let trunkPositions = [], branchPositions = [];
        let isTree = true;
        let mouseX = 0, mouseY = 0;
        let animationId = null;
        let frameCount = 0;
        let lastTime = Date.now();
        let fps = 60;
        let trunkOriginalOpacity, branchOriginalOpacity;
        
        // ==================== ä¸»åˆå§‹åŒ– ====================
        async function init() {
            const loadingScreen = document.getElementById('loading-screen');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
            }
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.backgroundColor);
            
            // åˆ›å»ºç›¸æœº - è°ƒæ•´è§†è§’è®©ç‰©ä½“æ›´å±…ä¸­
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 14;
            camera.position.y = 4;  // é™ä½ç›¸æœºé«˜åº¦ï¼Œè®©ç‰©ä½“çœ‹èµ·æ¥æ›´é«˜
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, CONFIG.ambientLightIntensity);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff69b4, 0.8);
            directionalLight.position.set(15, 15, 10);
            scene.add(directionalLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-10, 5, -10);
            scene.add(backLight);
            
            // ç”Ÿæˆé«˜å¯†åº¦ç²’å­æ•°æ®ï¼ˆåº”ç”¨å‚ç›´åç§»ï¼‰
            generateParticleDataWithOffset();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystems();
            
            // ä¿å­˜åŸå§‹é€æ˜åº¦ç”¨äºåŠ¨ç”»
            trunkOriginalOpacity = trunkMaterial.opacity;
            branchOriginalOpacity = branchMaterial.opacity;
            
            // æ›´æ–°æ˜¾ç¤º
            updateParticleCount();
            
            // è®¾ç½®äº¤äº’
            setupInteractions();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯å’Œæ€§èƒ½ç›‘æ§
            animate();
            monitorPerformance();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 800);
            }, 1000);
            
            console.log('ğŸ„ ä¿®å¤ç‰ˆåœ£è¯æ ‘åˆå§‹åŒ–å®Œæˆï¼æ€»ç²’å­æ•°:', 
                CONFIG.crownParticleCount + CONFIG.trunkParticleCount + CONFIG.branchParticleCount);
        }
        
        // ==================== ç”Ÿæˆå¸¦å‚ç›´åç§»çš„ç²’å­æ•°æ® ====================
        function generateParticleDataWithOffset() {
            // æ¸…ç©ºæ•°ç»„
            crownPositions = []; heartPositions = [];
            trunkPositions = []; branchPositions = [];
            
            // 1. ç”Ÿæˆæ ‘å† ç²’å­ - åœ£è¯æ ‘å½¢çŠ¶ï¼ˆåº”ç”¨å‚ç›´åç§»ï¼‰
            console.log("ç”Ÿæˆåœ£è¯æ ‘ç²’å­...");
            const treeLayers = 6;
            for (let layer = 0; layer < treeLayers; layer++) {
                const layerParticles = Math.floor(CONFIG.crownParticleCount / treeLayers);
                const layerHeight = layer * 0.9;
                const layerRadius = 4.0 - layer * 0.5;
                
                for (let i = 0; i < layerParticles; i++) {
                    const angle = (i / layerParticles) * Math.PI * 2 + Math.random() * 0.1;
                    const radius = Math.sqrt(Math.random()) * layerRadius;
                    const effectiveRadius = radius * (1 - layer * 0.12);
                    const height = layerHeight + Math.random() * 0.7;
                    
                    // åº”ç”¨å‚ç›´åç§»ï¼šåœ£è¯æ ‘ä¸Šç§»
                    crownPositions.push(
                        Math.cos(angle) * effectiveRadius,
                        height + CONFIG.treeVerticalOffset,  // å…³é”®ä¿®æ”¹ï¼šåœ£è¯æ ‘ä¸Šç§»
                        Math.sin(angle) * effectiveRadius
                    );
                }
            }
            
            // 2. ç”Ÿæˆæ ‘å† ç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆåº”ç”¨å‚ç›´åç§»ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒç²’å­...");
            for (let i = 0; i < CONFIG.crownParticleCount; i++) {
                const u = Math.random();
                const v = Math.random();
                const t = v * Math.PI * 2;
                const r = Math.sqrt(u) * 1.2;
                
                const x = 16 * Math.pow(Math.sin(t), 3) * r;
                const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * r;
                const z = (Math.random() - 0.5) * 3.0 * (1 - u);
                
                // åº”ç”¨å‚ç›´åç§»ï¼šçˆ±å¿ƒä¸Šç§»ï¼ˆæ¯”åœ£è¯æ ‘åç§»å°‘ï¼‰
                heartPositions.push(
                    x * 0.045,
                    y * 0.045 + CONFIG.heartVerticalOffset,  // å…³é”®ä¿®æ”¹ï¼šçˆ±å¿ƒä¸Šç§»
                    z * 0.5
                );
            }
            
            // 3. ç”Ÿæˆæ ‘å¹²ç²’å­ - åœ£è¯æ ‘å½¢çŠ¶ï¼ˆåº”ç”¨ç›¸åŒå‚ç›´åç§»ï¼‰
            console.log("ç”Ÿæˆæ ‘å¹²ç²’å­...");
            const trunkHeight = 5.0;
            const trunkBaseRadius = 0.9;
            
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const height = -2.5 + (Math.random() * trunkHeight);
                const normalizedHeight = (height + 2.5) / trunkHeight;
                const radius = trunkBaseRadius * (1 - normalizedHeight * 0.4);
                const angle = Math.random() * Math.PI * 2;
                const irregularity = Math.sin(height * 3) * 0.1;
                
                // åº”ç”¨ä¸æ ‘å† ç›¸åŒçš„å‚ç›´åç§»
                trunkPositions.push(
                    Math.cos(angle) * (radius + irregularity),
                    height + CONFIG.treeVerticalOffset,  // ä¸åœ£è¯æ ‘åŒæ­¥ä¸Šç§»
                    Math.sin(angle) * radius
                );
            }
            
            // 4. ç”Ÿæˆæ ‘æç²’å­ - åœ£è¯æ ‘å½¢çŠ¶ï¼ˆåº”ç”¨ç›¸åŒå‚ç›´åç§»ï¼‰
            console.log("ç”Ÿæˆæ ‘æç²’å­...");
            const branchLayers = [-0.5, 0.8, 2.0, 3.2];
            const branchesPerLayer = 8;
            
            for (let layer = 0; layer < branchLayers.length; layer++) {
                const layerHeight = branchLayers[layer];
                
                for (let branch = 0; branch < branchesPerLayer; branch++) {
                    const angle = (branch / branchesPerLayer) * Math.PI * 2;
                    const branchLength = 1.2 + Math.random() * 1.5;
                    const particlesPerBranch = Math.floor(CONFIG.branchParticleCount / (branchLayers.length * branchesPerLayer));
                    
                    for (let p = 0; p < particlesPerBranch; p++) {
                        const t = Math.random();
                        const curve = Math.sin(t * Math.PI) * 0.3;
                        const radius = 0.6 + branchLength * t;
                        const height = layerHeight - t * 0.5 + curve;
                        const jitter = (Math.random() - 0.5) * 0.3;
                        
                        // åº”ç”¨ä¸åœ£è¯æ ‘ç›¸åŒçš„å‚ç›´åç§»
                        branchPositions.push(
                            Math.cos(angle + curve) * radius + jitter,
                            height + CONFIG.treeVerticalOffset,  // ä¸åœ£è¯æ ‘åŒæ­¥ä¸Šç§»
                            Math.sin(angle + curve) * radius + jitter
                        );
                    }
                }
            }
            
            console.log("ç²’å­æ•°æ®ç”Ÿæˆå®Œæˆ");
        }
        
        // ==================== åˆ›å»ºç²’å­ç³»ç»Ÿ ====================
        function createParticleSystems() {
            // 1. åˆ›å»ºæ ‘å† ç²’å­ç³»ç»Ÿ
            crownGeometry = new THREE.BufferGeometry();
            crownGeometry.setAttribute('position', new THREE.Float32BufferAttribute(crownPositions, 3));
            
            crownMaterial = new THREE.PointsMaterial({
                color: CONFIG.crownColor,
                size: CONFIG.crownParticleSize,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            crownParticles = new THREE.Points(crownGeometry, crownMaterial);
            scene.add(crownParticles);
            
            // 2. åˆ›å»ºæ ‘å¹²ç²’å­ç³»ç»Ÿ
            trunkGeometry = new THREE.BufferGeometry();
            trunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trunkPositions, 3));
            
            trunkMaterial = new THREE.PointsMaterial({
                color: CONFIG.trunkColor,
                size: CONFIG.trunkParticleSize,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });
            
            trunkParticles = new THREE.Points(trunkGeometry, trunkMaterial);
            scene.add(trunkParticles);
            
            // 3. åˆ›å»ºæ ‘æç²’å­ç³»ç»Ÿ
            branchGeometry = new THREE.BufferGeometry();
            branchGeometry.setAttribute('position', new THREE.Float32BufferAttribute(branchPositions, 3));
            
            branchMaterial = new THREE.PointsMaterial({
                color: CONFIG.branchColor,
                size: CONFIG.branchParticleSize,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true
            });
            
            branchParticles = new THREE.Points(branchGeometry, branchMaterial);
            scene.add(branchParticles);
        }
        
        // ==================== å½¢çŠ¶åˆ‡æ¢ï¼ˆä¿®å¤ç‰ˆï¼šéšè—æ£•è‰²ç²’å­ï¼‰ ====================
        function switchShape() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            const crownPos = crownGeometry.attributes.position.array;
            const targetCrown = isTree ? heartPositions : crownPositions;
            
            const startCrown = [...crownPos];
            const startTime = Date.now();
            const duration = 1800;
            
            // è®°å½•å½“å‰æ ‘å¹²å’Œæ ‘æçš„é€æ˜åº¦
            const trunkStartOpacity = trunkMaterial.opacity;
            const branchStartOpacity = branchMaterial.opacity;
            
            // ç›®æ ‡é€æ˜åº¦ï¼šåˆ‡æ¢åˆ°çˆ±å¿ƒæ—¶æ·¡å‡ºï¼Œåˆ‡æ¢å›åœ£è¯æ ‘æ—¶æ¢å¤
            const trunkTargetOpacity = isTree ? 0 : trunkOriginalOpacity;
            const branchTargetOpacity = isTree ? 0 : branchOriginalOpacity;
            
            function transition() {
                const elapsed = Date.now() - startTime;
                let progress = Math.min(elapsed / duration, 1);
                
                // å¹³æ»‘ç¼“åŠ¨å‡½æ•°
                progress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // æ ‘å† ç²’å­è¿‡æ¸¡
                for (let i = 0; i < crownPos.length; i++) {
                    crownPos[i] = startCrown[i] + (targetCrown[i] - startCrown[i]) * progress;
                }
                
                // æ ‘å¹²å’Œæ ‘æé€æ˜åº¦è¿‡æ¸¡ï¼ˆæ·¡å…¥æ·¡å‡ºï¼‰
                if (elapsed < CONFIG.trunkFadeOutDuration) {
                    const trunkProgress = Math.min(elapsed / CONFIG.trunkFadeOutDuration, 1);
                    trunkMaterial.opacity = trunkStartOpacity + (trunkTargetOpacity - trunkStartOpacity) * trunkProgress;
                }
                
                if (elapsed < CONFIG.branchFadeOutDuration) {
                    const branchProgress = Math.min(elapsed / CONFIG.branchFadeOutDuration, 1);
                    branchMaterial.opacity = branchStartOpacity + (branchTargetOpacity - branchStartOpacity) * branchProgress;
                }
                
                // å¦‚æœéœ€è¦ï¼Œä¹Ÿå¯ä»¥ç¼©å°æ ‘å¹²å’Œæ ‘æç²’å­
                if (isTree) {
                    // åˆ‡æ¢åˆ°çˆ±å¿ƒæ—¶ï¼Œé€æ¸ç¼©å°æ ‘å¹²å’Œæ ‘æ
                    const shrinkProgress = Math.min(elapsed / 800, 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize * (1 - shrinkProgress * 0.8);
                    branchMaterial.size = CONFIG.branchParticleSize * (1 - shrinkProgress * 0.8);
                } else {
                    // åˆ‡æ¢å›åœ£è¯æ ‘æ—¶ï¼Œæ¢å¤å¤§å°
                    const restoreProgress = Math.min(elapsed / 600, 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize * (0.2 + restoreProgress * 0.8);
                    branchMaterial.size = CONFIG.branchParticleSize * (0.2 + restoreProgress * 0.8);
                }
                
                // æ›´æ–°å‡ ä½•ä½“å’Œæè´¨
                crownGeometry.attributes.position.needsUpdate = true;
                trunkMaterial.needsUpdate = true;
                branchMaterial.needsUpdate = true;
                
                if (progress < 1) {
                    animationId = requestAnimationFrame(transition);
                } else {
                    isTree = !isTree;
                    updateUI();
                    animationId = null;
                    
                    // ç¡®ä¿æœ€ç»ˆçŠ¶æ€æ­£ç¡®
                    if (!isTree) {
                        trunkMaterial.opacity = 0;
                        branchMaterial.opacity = 0;
                        trunkMaterial.size = CONFIG.trunkParticleSize * 0.2;
                        branchMaterial.size = CONFIG.branchParticleSize * 0.2;
                    } else {
                        trunkMaterial.opacity = trunkOriginalOpacity;
                        branchMaterial.opacity = branchOriginalOpacity;
                        trunkMaterial.size = CONFIG.trunkParticleSize;
                        branchMaterial.size = CONFIG.branchParticleSize;
                    }
                }
            }
            
            animationId = requestAnimationFrame(transition);
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * CONFIG.floatSpeed;
            frameCount++;
            
            // æ ¹æ®å½¢çŠ¶è°ƒæ•´æ—‹è½¬é€Ÿåº¦
            const currentRotationSpeed = CONFIG.rotationSpeed * (isTree ? 1.0 : 0.7);
            
            // æ•´ä½“æ—‹è½¬ (å—é¼ æ ‡æ§åˆ¶)
            crownParticles.rotation.y += currentRotationSpeed + mouseX * 0.0015;
            crownParticles.rotation.x = Math.sin(time) * 0.03 + mouseY * 0.04;
            
            // æ ‘å† ç²’å­æµ®åŠ¨æ•ˆæœ
            const crownPos = crownGeometry.attributes.position.array;
            const originalCrown = isTree ? crownPositions : heartPositions;
            
            for (let i = 0; i < crownPos.length; i += 3) {
                const idx = i / 3;
                const float1 = Math.sin(time + idx * 0.05) * CONFIG.floatAmplitude;
                const float2 = Math.cos(time * 0.7 + idx * 0.03) * CONFIG.floatAmplitude * 0.5;
                
                crownPos[i] = originalCrown[i] + float1 * 0.3 + float2;
                crownPos[i + 1] = originalCrown[i + 1] + float1 * 0.7;
                crownPos[i + 2] = originalCrown[i + 2] + float1 * 0.2 + float2 * 0.5;
            }
            
            crownGeometry.attributes.position.needsUpdate = true;
            
            // æ ‘å¹²å’Œæ ‘æè·Ÿéšæ—‹è½¬ï¼ˆåªåœ¨åœ£è¯æ ‘æ¨¡å¼ä¸‹å¯è§ï¼‰
            if (isTree) {
                trunkParticles.rotation.y = crownParticles.rotation.y;
                trunkParticles.rotation.x = crownParticles.rotation.x;
                branchParticles.rotation.y = crownParticles.rotation.y;
                branchParticles.rotation.x = crownParticles.rotation.x;
            }
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }
        
        // ==================== æ€§èƒ½ç›‘æ§ ====================
        function monitorPerformance() {
            setInterval(() => {
                const now = Date.now();
                fps = Math.round((frameCount * 1000) / (now - lastTime));
                frameCount = 0;
                lastTime = now;
                
                const warningEl = document.getElementById('performance-warning');
                if (fps < 30) {
                    warningEl.textContent = `æ€§èƒ½: ${fps}FPS (è¾ƒä½)`;
                    warningEl.style.color = '#ff6b6b';
                    warningEl.style.display = 'block';
                } else if (fps < 50) {
                    warningEl.textContent = `æ€§èƒ½: ${fps}FPS`;
                    warningEl.style.color = '#feca57';
                    warningEl.style.display = 'block';
                } else {
                    warningEl.style.display = 'none';
                }
            }, 1000);
        }
        
        // ==================== æ›´æ–°ç•Œé¢ ====================
        function updateUI() {
            const title = document.querySelector('h1');
            const btn = document.getElementById('btn-switch');
            
            if (isTree) {
                title.innerHTML = 'âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºçˆ±å¿ƒ';
            } else {
                title.innerHTML = 'â¤ï¸ æˆ‘çˆ±ä½ å®å® â¤ï¸';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºåœ£è¯æ ‘';
            }
            
            updateParticleCount();
        }
        
        // ==================== æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º ====================
        function updateParticleCount() {
            const totalParticles = CONFIG.crownParticleCount + CONFIG.trunkParticleCount + CONFIG.branchParticleCount;
            const visibleParticles = isTree ? totalParticles : CONFIG.crownParticleCount;
            document.getElementById('particle-count').textContent = `å¯è§ç²’å­: ${visibleParticles.toLocaleString()}`;
        }
        
        // ==================== è®¾ç½®äº¤äº’ ====================
        function setupInteractions() {
            // é¼ æ ‡ç§»åŠ¨æ§åˆ¶è§†è§’
            let isDragging = false;
            let lastMouseX = 0, lastMouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    mouseX = deltaX * 0.01;
                    mouseY = deltaY * 0.01;
                } else {
                    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                }
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // è§¦æ‘¸æ§åˆ¶
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }
            }, { passive: true });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - lastMouseX;
                    const deltaY = e.touches[0].clientY - lastMouseY;
                    mouseX = deltaX * 0.02;
                    mouseY = deltaY * 0.02;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }
            }, { passive: true });
            
            // é”®ç›˜æ§åˆ¶
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyH' || e.code === 'Space') {
                    switchShape();
                }
                if (e.code === 'KeyR') {
                    resetToTree();
                }
            });
            
            // ç‚¹å‡»åˆ‡æ¢
            renderer.domElement.addEventListener('click', (e) => {
                if (e.target === renderer.domElement) {
                    switchShape();
                }
            });
            
            // ç§»åŠ¨ç«¯æŒ‰é’®
            const switchBtn = document.getElementById('btn-switch');
            const resetBtn = document.getElementById('btn-reset');
            
            if (switchBtn) {
                switchBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    switchShape();
                });
                
                switchBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    switchShape();
                }, { passive: false });
            }
            
            if (resetBtn) {
                resetBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    resetToTree();
                });
                
                resetBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    resetToTree();
                }, { passive: false });
            }
            
            // åŒå‡»é‡ç½®è§†è§’
            renderer.domElement.addEventListener('dblclick', resetView);
        }
        
        // ==================== é‡ç½®ä¸ºåœ£è¯æ ‘ ====================
        function resetToTree() {
            if (!isTree) {
                switchShape();
            }
            
            resetView();
        }
        
        // ==================== é‡ç½®è§†è§’ ====================
        function resetView() {
            camera.position.z = 14;
            camera.position.y = 4;
            camera.lookAt(0, CONFIG.treeVerticalOffset, 0);
            mouseX = 0;
            mouseY = 0;
        }
        
        // ==================== çª—å£å¤§å°è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>




