<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å²³æ¬£å®œ(å®á´—å®)çš„åœ£è¯æ ‘ğŸ„>å²³æ¬£å®œ>yxy
  <!-- Three.js å›½å†…ç¨³å®šCDN -->
  <script src="https://cdn.bootcdn.net/ajax/libs/three.js/0.155.0/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    .info {
      position: absolute; 
      top: 10px; 
      left: 50%; 
      transform: translateX(-50%);
      color: #fff; 
      font-family: "Microsoft YaHei", Arial, sans-serif; 
      font-size: 16px;
      z-index: 999;
    }
  </style>
</head>
<body>
  <div class="info">Merry Christmas</div>
  <script>
    // ========== æ ¸å¿ƒé…ç½®ï¼ˆç²‰è‰²ä¸»é¢˜+æµªæ¼«ç²’å­ï¼‰ ==========
    const TREE_HEIGHT = 8;      // åœ£è¯æ ‘é«˜åº¦ï¼ˆæ›´é«˜æ›´ç«‹ä½“ï¼‰
    const TREE_RADIUS = 4;     // åœ£è¯æ ‘åº•éƒ¨åŠå¾„
    const LAYERS = 25;         // åˆ†å±‚æ•°ï¼ˆæ›´å¤šå±‚æ›´ç»†è…»ï¼‰
    const PARTICLE_COUNT = 5000; // ç²’å­æ•°ï¼ˆæ›´å¯†é›†ï¼‰
    const SNOW_COUNT = 150;    // é›ªèŠ±æ•°ï¼ˆæ›´æ¢¦å¹»ï¼‰
    const HEART_TOP_SIZE = 3;  // æ ‘é¡¶çˆ±å¿ƒå°ºå¯¸
    const PINK_COLOR = new THREE.Color(0xff9ac1); // ä¸»ç²‰è‰²

    // ========== 1. åˆå§‹åŒ– Three.js æ ¸å¿ƒ ==========
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ========== 2. å…‰ç…§ç³»ç»Ÿï¼ˆç²‰è‰²æš–å…‰ï¼‰ ==========
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(PINK_COLOR, 1.8); // ç²‰è‰²èšå…‰
    spotLight.position.set(6, TREE_HEIGHT / 2 + 2, 6);
    spotLight.target.position.set(0, 0, 0);
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 0.4;
    spotLight.castShadow = true;
    scene.add(spotLight);
    scene.add(spotLight.target);

    // ========== 3. ç²‰è‰²åœ£è¯æ ‘ç²’å­ç³»ç»Ÿ ==========
    const treeGeometry = new THREE.BufferGeometry();
    const treePositions = new Float32Array(PARTICLE_COUNT * 3);
    const treeColors = new Float32Array(PARTICLE_COUNT * 3);

    const layerHeight = TREE_HEIGHT / LAYERS;
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const layer = Math.floor(Math.random() * LAYERS);
      const y = -TREE_HEIGHT / 2 + layer * layerHeight;
      const radius = TREE_RADIUS * (1 - layer / LAYERS);
      const angle = Math.random() * Math.PI * 2;

      treePositions[i * 3] = radius * Math.cos(angle);
      treePositions[i * 3 + 1] = y;
      treePositions[i * 3 + 2] = radius * Math.sin(angle);

      // ç²‰è‰²æ¸å˜ï¼ˆæµ…ç²‰â†’æ·±ç²‰ï¼‰
      const r = 0.9 + Math.random() * 0.1;
      const g = 0.5 + Math.random() * 0.2;
      const b = 0.7 + Math.random() * 0.2;
      treeColors[i * 3] = r;
      treeColors[i * 3 + 1] = g;
      treeColors[i * 3 + 2] = b;
    }
    treeGeometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
    treeGeometry.setAttribute('color', new THREE.BufferAttribute(treeColors, 3));

    const treeMaterial = new THREE.PointsMaterial({
      size: 2,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const treeParticles = new THREE.Points(treeGeometry, treeMaterial);
    scene.add(treeParticles);

    // ========== 4. ç²’å­æ‹–å°¾ç‰¹æ•ˆï¼ˆå¢å¼ºæµåŠ¨æ„Ÿï¼‰ ==========
    const trailGeometry = new THREE.BufferGeometry();
    const trailPositions = new Float32Array(PARTICLE_COUNT * 3 * 3); // 3å¸§æ‹–å°¾
    const trailColors = new Float32Array(PARTICLE_COUNT * 3 * 3);
    trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));

    const trailMaterial = new THREE.PointsMaterial({
      size: 1.5,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      opacity: 0.7
    });
    const trailParticles = new THREE.Points(trailGeometry, trailMaterial);
    scene.add(trailParticles);

    const particleTrails = new Array(PARTICLE_COUNT).fill(0).map(() => []);

    // ========== 5. æ ‘é¡¶çˆ±å¿ƒï¼ˆè§†é¢‘åŒæ¬¾æ ¸å¿ƒï¼‰ ==========
    const heartTopTexture = new THREE.TextureLoader().load(
      'https://cdn.jsdelivr.net/gh/loadingio/cdn@master/heart.png' // çˆ±å¿ƒé¡¶è´´å›¾
    );
    const heartTopMaterial = new THREE.SpriteMaterial({
      map: heartTopTexture,
      color: 0xff4d88, // æ·±ç²‰è‰²çˆ±å¿ƒ
      transparent: true
    });
    const heartTop = new THREE.Sprite(heartTopMaterial);
    heartTop.scale.set(HEART_TOP_SIZE, HEART_TOP_SIZE, 1);
    heartTop.position.set(0, TREE_HEIGHT / 2 + 1, 0); // æ ‘é¡¶ä½ç½®
    scene.add(heartTop);

    // ========== 6. é›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆæ˜Ÿç©ºæ„Ÿï¼‰ ==========
    const snowGeometry = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(SNOW_COUNT * 3);
    const snowColors = new Float32Array(SNOW_COUNT * 3);

    for (let i = 0; i < SNOW_COUNT; i++) {
      const x = (Math.random() - 0.5) * 15;
      const y = 10 + Math.random() * 8;
      const z = (Math.random() - 0.5) * 15;
      snowPositions[i * 3] = x;
      snowPositions[i * 3 + 1] = y;
      snowPositions[i * 3 + 2] = z;

      // ç™½è‰²é›ªèŠ±å¸¦ç²‰å…‰
      const r = 1.0;
      const g = 0.9;
      const b = 1.0;
      snowColors[i * 3] = r;
      snowColors[i * 3 + 1] = g;
      snowColors[i * 3 + 2] = b;
    }
    snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
    snowGeometry.setAttribute('color', new THREE.BufferAttribute(snowColors, 3));

    const snowMaterial = new THREE.PointsMaterial({
      size: 1.5,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
    scene.add(snowParticles);

    function updateSnow() {
      const snowPos = snowParticles.geometry.attributes.position.array;
      for (let i = 0; i < SNOW_COUNT; i++) {
        const yIndex = i * 3 + 1;
        snowPos[yIndex] -= 0.025; // é›ªèŠ±é€Ÿåº¦
        if (snowPos[yIndex] < -TREE_HEIGHT / 2 - 5) {
          snowPos[yIndex] = 20; // é›ªèŠ±é«˜åº¦
          snowPos[i * 3] = (Math.random() - 0.5) * 15;
          snowPos[i * 3 + 2] = (Math.random() - 0.5) * 15;
        }
      }
      snowParticles.geometry.attributes.position.needsUpdate = true;
    }

    // ========== 7. åŠ¨ç”»å¾ªç¯ï¼ˆç¼“æ…¢æ—‹è½¬+æ‹–å°¾ï¼‰ ==========
    camera.position.z = 15;

    function animate() {
      requestAnimationFrame(animate);

      // åœ£è¯æ ‘+çˆ±å¿ƒé¡¶ åŒæ­¥æ—‹è½¬
      treeParticles.rotation.y += 0.002;
      heartTop.rotation.y += 0.002;

      // æ›´æ–°ç²’å­æ‹–å°¾
      let trailIndex = 0;
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const pos = treeParticles.geometry.attributes.position.array;
        const x = pos[i * 3];
        const y = pos[i * 3 + 1];
        const z = pos[i * 3 + 2];

        particleTrails[i].unshift({ x, y, z });
        particleTrails[i] = particleTrails[i].slice(0, 3);

        for (let j = 0; j < particleTrails[i].length; j++) {
          const p = particleTrails[i][j];
          trailPositions[trailIndex * 3] = p.x;
          trailPositions[trailIndex * 3 + 1] = p.y;
          trailPositions[trailIndex * 3 + 2] = p.z;

          const fade = 1 - j * 0.25;
          trailColors[trailIndex * 3] = treeColors[i * 3] * fade;
          trailColors[trailIndex * 3 + 1] = treeColors[i * 3 + 1] * fade;
          trailColors[trailIndex * 3 + 2] = treeColors[i * 3 + 2] * fade;
          trailIndex++;
        }
      }
      trailGeometry.attributes.position.needsUpdate = true;
      trailGeometry.attributes.color.needsUpdate = true;

      updateSnow();
      renderer.render(scene, camera);
    }
    animate();

    // ========== 8. çª—å£é€‚é… ==========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

