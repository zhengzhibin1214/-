<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å²³æ¬£å®œ(å®á´—å®)çš„ğŸ„</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(180deg, #0a0a2a 0%, #1a1a3a 30%, #2a2a4a 100%);
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: #ff69b4;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 10px;
            pointer-events: none;
        }
        h1 {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.9);
        }
        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            display: none;
        }
        .mobile-btn {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(255, 105, 180, 0.6);
            transition: all 0.3s;
            font-weight: bold;
        }
        .mobile-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(255, 105, 180, 0.8);
        }
        #particle-count {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 10px;
        }
        #mode-indicator {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .mode-text {
            display: inline-block;
            background: rgba(255, 105, 180, 0.2);
            color: #ff69b4;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.5s;
        }
        #snow-control {
            position: absolute;
            top: 120px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .snow-text {
            display: inline-block;
            background: rgba(173, 216, 230, 0.2);
            color: #add8e6;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p style="color: #ff69b4; margin-top: 20px;">æ­£åœ¨å®šåˆ¶ä¸“å±åœ£è¯æ ‘â¤ï¸...</p>
    </div>

    <div id="container">
        <div id="ui">
            <h1>âœ¨ ~(ï½¡â‰§3â‰¦)ï¾‰âŒ’â˜†å®å®çš„åœ£è¯æ ‘ âœ¨</h1>
            <p class="instructions">ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | é¼ æ ‡/æ‰‹æŒ‡æ‹–åŠ¨æ—‹è½¬ | æŒ‰ S é”®åˆ‡æ¢é›ªèŠ±</p>
        </div>
        
        <div id="mode-indicator">
            <span class="mode-text" id="mode-text">åœ£è¯æ ‘æ¨¡å¼</span>
        </div>
        
        <div id="snow-control">
            <span class="snow-text" id="snow-text">é›ªèŠ±: å¼€å¯</span>
        </div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-switch">åˆ‡æ¢ä¸ºçˆ±å¿ƒ</button>
            <button class="mobile-btn" id="btn-snow">åˆ‡æ¢é›ªèŠ±</button>
        </div>
        
        <div id="particle-count">ç²’å­æ•°: 0</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            // å¤šå±‚èºæ—‹æ ‘å† é…ç½® - å¢åŠ ç²’å­å¯†åº¦
            spiralTurns: 6,               // å¢åŠ èºæ—‹åœˆæ•°
            treeHeight: 9,
            baseRadius: 5.0,
            topRadius: 0.3,
            particlesPerTurn: 350,        // å¤§å¹…å¢åŠ æ¯åœˆç²’å­æ•°
            
            // æ˜Ÿæ˜Ÿé…ç½® - ç«–ç›´æ˜Ÿæ˜Ÿ
            starParticleCount: 100,       // å¢åŠ æ˜Ÿæ˜Ÿç²’å­æ•°
            starColor: 0xFFD700,
            starSize: 0.15,               // ç¨å¾®å¢å¤§æ˜Ÿæ˜Ÿç²’å­
            
            // æ ‘å¹²å’Œæ ‘æ
            trunkParticleCount: 240,
            branchParticleCount: 400,     // å¢åŠ æ ‘æç²’å­
            
            // é›ªèŠ±å’Œé›ªåœ°é…ç½®
            snowParticleCount: 400,
            groundSnowParticleCount: 900, // å¢åŠ åœ°é¢é›ªç²’å­
            snowColor: 0xF0F8FF,
            groundSnowColor: 0xFFFFFF,
            snowEnabled: true,
            
            // æ ‘å† é¢œè‰²ï¼ˆæ•´ä½“æ¸å˜ - ä»åº•éƒ¨æ·±ç²‰è‰²åˆ°é¡¶éƒ¨æµ…ç²‰è‰²ï¼‰
            crownBaseColor: 0xFF1493,     // åº•éƒ¨ï¼šæ›´æ·±çš„ç²‰è‰²
            crownTopColor: 0xFFB6C1,      // é¡¶éƒ¨ï¼šæµ…ç²‰è‰²
            
            // å…¶ä»–é¢œè‰²
            trunkColor: 0x8B4513,
            branchColor: 0xA0522D,
            heartBaseColor: 0xFFB6C1,
            
            // ç²’å­å¤§å°
            crownParticleSize: 0.065,     // ç¨å¾®å‡å°ç²’å­å¤§å°ä»¥é€‚åº”æ›´å¤šç²’å­
            trunkParticleSize: 0.088,
            branchParticleSize: 0.072,
            groundSnowSize: 0.11,
            
            // ä½ç½®è°ƒæ•´
            treeVerticalPosition: -2.5,
            groundSnowHeight: -4.0,
            groundSnowRadius: 8.5,
            
            // åŠ¨ç”»
            rotationSpeed: 0.0018,
            floatAmplitude: 0.014,
            floatSpeed: 0.00035,
            starTwinkleSpeed: 0.002,
            starTwinkleAmplitude: 0.15,
            
            // æ˜Ÿæ˜Ÿæ•£è½é…ç½®
            starFallDuration: 1800,       // æ˜Ÿæ˜Ÿæ•£è½æŒç»­æ—¶é—´
            starFallSpeed: 0.05,          // æ˜Ÿæ˜Ÿæ•£è½é€Ÿåº¦
            starScatterRadius: 6.0,       // æ˜Ÿæ˜Ÿæ•£è½èŒƒå›´
            
            // è¿‡æ¸¡é…ç½®
            transitionDuration: 2000,
            colorTransitionDelay: 300
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let crownParticles, trunkParticles, branchParticles, snowParticles, groundSnowParticles, starParticles;
        let crownGeometry, trunkGeometry, branchGeometry, snowGeometry, groundSnowGeometry, starGeometry;
        let crownMaterial, trunkMaterial, branchMaterial, snowMaterial, groundSnowMaterial, starMaterial;
        
        // ç²’å­ä½ç½®å’Œé¢œè‰²æ•°ç»„
        let crownTreePositions = [], crownHeartPositions = [];
        let crownTreeColors = [], crownHeartColors = [];
        let trunkTreePositions = [], trunkHeartPositions = [];
        let branchTreePositions = [], branchHeartPositions = [];
        let snowPositions = [], snowVelocities = [];
        let groundSnowPositions = [];
        let starPositions = [], starHeartPositions = [];
        let starColors = [];
        
        // æ˜Ÿæ˜Ÿæ•£è½ç›¸å…³å˜é‡
        let starFallPositions = [];       // æ˜Ÿæ˜Ÿæ•£è½ç›®æ ‡ä½ç½®
        let starFallVelocities = [];      // æ˜Ÿæ˜Ÿæ•£è½é€Ÿåº¦
        let starFallActive = false;       // æ˜Ÿæ˜Ÿæ˜¯å¦æ­£åœ¨æ•£è½
        let starFallStartTime = 0;        // æ˜Ÿæ˜Ÿæ•£è½å¼€å§‹æ—¶é—´
        let starOriginalPositions = [];   // æ˜Ÿæ˜ŸåŸå§‹ä½ç½®å¤‡ä»½
        
        // é¢œè‰²æ•°ç»„
        let trunkTreeColors = [], trunkHeartColors = [];
        let branchTreeColors = [], branchHeartColors = [];
        
        let isTree = true;
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let transitionInProgress = false;
        let snowEnabled = CONFIG.snowEnabled;
        
        // ==================== ä¸»åˆå§‹åŒ– ====================
        async function init() {
            const loadingScreen = document.getElementById('loading-screen');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
                document.querySelector('.instructions').textContent = 'ç‚¹å‡»æŒ‰é’®åˆ‡æ¢æ¨¡å¼ | æ‹–åŠ¨æ—‹è½¬';
            }
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a2a);
            
            // åˆ›å»ºç›¸æœº - æ–œä¸Šæ–¹45åº¦è§†è§’
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 11, 15);
            camera.lookAt(0, CONFIG.treeVerticalPosition + 3, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // ä¸»å…‰æºï¼ˆç²‰è‰²ï¼Œä»æ–œä¸Šæ–¹ç…§å°„ï¼‰
            const mainLight = new THREE.DirectionalLight(0xff69b4, 0.8);
            mainLight.position.set(10, 15, 10);
            scene.add(mainLight);
            
            // è¾…åŠ©å…‰æºï¼ˆç™½è‰²ï¼Œä»å¦ä¸€ä¾§è¡¥å…‰ï¼‰
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);
            
            // é›ªåœ°ä¸“ç”¨å…‰æº
            const snowLight = new THREE.DirectionalLight(0xadd8e6, 0.5);
            snowLight.position.set(5, 10, -5);
            scene.add(snowLight);
            
            // æ˜Ÿæ˜Ÿä¸“ç”¨å…‰æºï¼ˆé‡‘è‰²ï¼‰
            const starLight = new THREE.PointLight(0xFFD700, 0.8, 20);
            starLight.position.set(0, CONFIG.treeHeight + CONFIG.treeVerticalPosition + 0.5, 0);
            scene.add(starLight);
            
            // ç”Ÿæˆç²’å­æ•°æ®
            generateParticleData();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystems();
            
            // è®¾ç½®äº¤äº’
            setupInteractions();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 800);
            }, 1200);
            
            console.log('ğŸ„ å¤šå±‚æ ‘å† ä¸æ˜Ÿæ˜Ÿåœ£è¯æ ‘åˆå§‹åŒ–å®Œæˆï¼');
        }
        
        // ==================== ç”Ÿæˆç²’å­æ•°æ® ====================
        function generateParticleData() {
            // æ¸…ç©ºæ•°ç»„
            crownTreePositions = []; crownHeartPositions = [];
            crownTreeColors = []; crownHeartColors = [];
            trunkTreePositions = []; trunkHeartPositions = [];
            branchTreePositions = []; branchHeartPositions = [];
            trunkTreeColors = []; trunkHeartColors = [];
            branchTreeColors = []; branchHeartColors = [];
            snowPositions = []; snowVelocities = [];
            groundSnowPositions = [];
            starPositions = []; starHeartPositions = [];
            starColors = [];
            
            // 1. ç”Ÿæˆæ•´ä½“èºæ—‹é”¥å½¢æ ‘å† ç²’å­ - ä¸€ä½“æ¸å˜
            console.log("ç”Ÿæˆæ•´ä½“æ¸å˜æ ‘å† ç²’å­...");
            const totalParticles = CONFIG.spiralTurns * CONFIG.particlesPerTurn;
            
            // åº•éƒ¨å’Œé¡¶éƒ¨é¢œè‰²åˆ†é‡
            const baseR = (CONFIG.crownBaseColor >> 16 & 255) / 255;
            const baseG = (CONFIG.crownBaseColor >> 8 & 255) / 255;
            const baseB = (CONFIG.crownBaseColor & 255) / 255;
            
            const topR = (CONFIG.crownTopColor >> 16 & 255) / 255;
            const topG = (CONFIG.crownTopColor >> 8 & 255) / 255;
            const topB = (CONFIG.crownTopColor & 255) / 255;
            
            for (let i = 0; i < totalParticles; i++) {
                // è®¡ç®—å½’ä¸€åŒ–é«˜åº¦ (0 åˆ° 1)
                const t = i / totalParticles;
                
                // è®¡ç®—é«˜åº¦ï¼ˆä»ä¸‹åˆ°ä¸Šï¼‰
                const y = t * CONFIG.treeHeight;
                
                // è®¡ç®—åŠå¾„ï¼ˆéšç€é«˜åº¦å¢åŠ è€Œå‡å°ï¼Œä¸‹å¤§ä¸Šå°ï¼‰
                const radius = CONFIG.baseRadius * (1 - t) + CONFIG.topRadius * t;
                
                // è®¡ç®—èºæ—‹è§’åº¦
                const theta = CONFIG.spiralTurns * 2 * Math.PI * t;
                
                // æ·»åŠ ä¸€äº›éšæœºåç§»ï¼Œä½¿æ ‘å† æ›´è‡ªç„¶
                const randomOffsetX = (Math.random() - 0.5) * radius * 0.1;
                const randomOffsetY = (Math.random() - 0.5) * 0.3;
                const randomOffsetZ = (Math.random() - 0.5) * radius * 0.1;
                
                // è®¡ç®—ç²’å­ä½ç½®
                const x = Math.cos(theta) * radius + randomOffsetX;
                const z = Math.sin(theta) * radius + randomOffsetZ;
                
                // åº”ç”¨å‚ç›´ä½ç½®åç§»
                const verticalOffset = CONFIG.treeVerticalPosition;
                
                crownTreePositions.push(x, y + verticalOffset + randomOffsetY, z);
                
                // è®¡ç®—é¢œè‰²æ¸å˜ï¼ˆä»åº•éƒ¨æ·±ç²‰è‰²åˆ°é¡¶éƒ¨æµ…ç²‰è‰²ï¼Œæ•´ä½“è¿ç»­æ¸å˜ï¼‰
                const colorProgress = t * 0.85; // æ§åˆ¶æ¸å˜é€Ÿåº¦
                
                crownTreeColors.push(
                    baseR + (topR - baseR) * colorProgress,
                    baseG + (topG - baseG) * colorProgress,
                    baseB + (topB - baseB) * colorProgress
                );
            }
            
            // 2. ç”Ÿæˆçˆ±å¿ƒç²’å­
            console.log("ç”Ÿæˆçˆ±å¿ƒç²’å­...");
            for (let i = 0; i < totalParticles; i++) {
                const u = Math.random();
                const v = Math.random();
                const t = v * Math.PI * 2;
                const r = Math.sqrt(u) * 1.3;
                
                const x = 16 * Math.pow(Math.sin(t), 3) * r;
                const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * r;
                const z = (Math.random() - 0.5) * 2.5 * (1 - u);
                
                crownHeartPositions.push(
                    x * 0.045,
                    y * 0.045 + CONFIG.treeVerticalPosition + 2.5,
                    z * 0.6
                );
                
                // çˆ±å¿ƒé¢œè‰²ï¼ˆç²‰è‰²ç³»ï¼‰
                crownHeartColors.push(
                    0.9 + Math.random() * 0.1,
                    0.4 + Math.random() * 0.2,
                    0.6 + Math.random() * 0.2
                );
            }
            
            // 3. ç”Ÿæˆæ ‘å¹²ç²’å­ - åœ£è¯æ ‘å½¢çŠ¶
            console.log("ç”Ÿæˆæ ‘å¹²ç²’å­...");
            const trunkHeight = 5.5;
            
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const height = -2.5 + (Math.random() * trunkHeight);
                const normalizedHeight = (height + 2.5) / trunkHeight;
                const radius = 1.0 * (1 - normalizedHeight * 0.6);
                const angle = Math.random() * Math.PI * 2;
                
                trunkTreePositions.push(
                    Math.cos(angle) * radius * 0.7,
                    height + CONFIG.treeVerticalPosition,
                    Math.sin(angle) * radius
                );
                
                trunkTreeColors.push(
                    (CONFIG.trunkColor >> 16 & 255) / 255,
                    (CONFIG.trunkColor >> 8 & 255) / 255,
                    (CONFIG.trunkColor & 255) / 255
                );
            }
            
            // 4. ç”Ÿæˆæ ‘å¹²ç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆåœ†å½¢åº•åº§ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒåº•åº§ç²’å­...");
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 2.8 * (0.5 + Math.random() * 0.5);
                const y = -1.8;
                
                trunkHeartPositions.push(
                    Math.cos(angle) * radius,
                    y + CONFIG.treeVerticalPosition + 1,
                    Math.sin(angle) * radius
                );
                
                trunkHeartColors.push(
                    (CONFIG.heartBaseColor >> 16 & 255) / 255,
                    (CONFIG.heartBaseColor >> 8 & 255) / 255,
                    (CONFIG.heartBaseColor & 255) / 255
                );
            }
            
            // 5. ç”Ÿæˆæ ‘æç²’å­ - åœ£è¯æ ‘å½¢çŠ¶
            console.log("ç”Ÿæˆæ ‘æç²’å­...");
            const branchLevels = [0.3, 1.8, 3.4, 5.0, 6.6];
            
            for (let level = 0; level < branchLevels.length; level++) {
                const levelHeight = branchLevels[level];
                const branchCount = 6 + level * 2;
                
                for (let branch = 0; branch < branchCount; branch++) {
                    const angle = (branch / branchCount) * Math.PI * 2 + Math.random() * 0.5;
                    const branchLength = 0.9 + Math.random() * 1.6 + level * 0.4;
                    const particlesPerBranch = Math.floor(CONFIG.branchParticleCount / (branchLevels.length * branchCount));
                    
                    for (let p = 0; p < particlesPerBranch; p++) {
                        const t = Math.random();
                        const curve = Math.sin(t * Math.PI) * 0.35;
                        const radius = 0.7 + branchLength * t;
                        const height = levelHeight - t * 0.7 + curve;
                        const jitter = (Math.random() - 0.5) * 0.35;
                        
                        branchTreePositions.push(
                            Math.cos(angle + curve) * radius + jitter,
                            height + CONFIG.treeVerticalPosition,
                            Math.sin(angle + curve) * radius + jitter
                        );
                        
                        branchTreeColors.push(
                            (CONFIG.branchColor >> 16 & 255) / 255,
                            (CONFIG.branchColor >> 8 & 255) / 255,
                            (CONFIG.branchColor & 255) / 255
                        );
                    }
                }
            }
            
            // 6. ç”Ÿæˆæ ‘æç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆè£…é¥°ç²’å­ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒè£…é¥°ç²’å­...");
            for (let i = 0; i < CONFIG.branchParticleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 1.8 + Math.random() * 2.2;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta) + 1.2;
                const z = radius * Math.cos(phi);
                
                branchHeartPositions.push(
                    x * 0.45,
                    y * 0.45 + CONFIG.treeVerticalPosition + 2,
                    z * 0.45
                );
                
                const pinkValue = 0.8 + Math.random() * 0.2;
                branchHeartColors.push(
                    pinkValue,
                    pinkValue * 0.6,
                    pinkValue * 0.8
                );
            }
            
            // 7. ç”Ÿæˆæ˜Ÿæ˜Ÿç²’å­ - ç«–ç›´æ˜Ÿæ˜Ÿ
            console.log(`ç”Ÿæˆ${CONFIG.starParticleCount}ä¸ªæ˜Ÿæ˜Ÿç²’å­...`);
            const starHeight = CONFIG.treeHeight + CONFIG.treeVerticalPosition + 1.0;
            
            // ç”Ÿæˆæ˜Ÿæ˜Ÿçš„åŸå§‹ä½ç½®å¤‡ä»½
            starOriginalPositions = [];
            
            for (let i = 0; i < CONFIG.starParticleCount; i++) {
                // ç«–ç›´æ˜Ÿæ˜Ÿ - ä¸­å¿ƒèšé›†ï¼Œå‘ä¸Šä¼¸å±•
                const angle = (i / CONFIG.starParticleCount) * Math.PI * 2;
                const radius = 0.3 + Math.random() * 0.5;
                
                // ç«–ç›´åˆ†å¸ƒï¼šåº•éƒ¨ç²’å­å¯†åº¦é«˜ï¼Œå‘ä¸Šé€æ¸ç¨€ç–
                const verticalFactor = Math.pow(Math.random(), 2);
                const yOffset = verticalFactor * 1.2; // æ˜Ÿæ˜Ÿé«˜åº¦
                
                const x = Math.cos(angle) * radius * (1 - verticalFactor * 0.7);
                const z = Math.sin(angle) * radius * (1 - verticalFactor * 0.7);
                const y = starHeight + yOffset;
                
                starPositions.push(x, y, z);
                starOriginalPositions.push(x, y, z);
                
                // æ˜Ÿæ˜Ÿé¢œè‰²ï¼ˆé‡‘è‰²æ¸å˜ï¼Œé¡¶éƒ¨æ›´äº®ï¼‰
                const brightness = 0.7 + verticalFactor * 0.3;
                starColors.push(
                    brightness,           // R
                    brightness * 0.85,    // G
                    brightness * 0.1      // B
                );
            }
            
            // 8. ç”Ÿæˆæ˜Ÿæ˜Ÿç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆç©ºçš„ï¼Œå› ä¸ºæ˜Ÿæ˜Ÿä¼šæ¶ˆå¤±ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒé¡¶éƒ¨æ˜Ÿæ˜Ÿç²’å­ï¼ˆç©ºçš„ï¼‰...");
            for (let i = 0; i < CONFIG.starParticleCount; i++) {
                // çˆ±å¿ƒæ¨¡å¼ä¸‹æ˜Ÿæ˜Ÿä¼šæ•£è½æ¶ˆå¤±ï¼Œæ‰€ä»¥ä½ç½®è®¾ä¸º0
                starHeartPositions.push(0, -10, 0); // éšè—åˆ°åœ°ä¸‹
            }
            
            // 9. ç”Ÿæˆç©ºä¸­é›ªèŠ±ç²’å­
            console.log(`ç”Ÿæˆ${CONFIG.snowParticleCount}ä¸ªé›ªèŠ±ç²’å­...`);
            const snowArea = 32;
            
            for (let i = 0; i < CONFIG.snowParticleCount; i++) {
                const x = (Math.random() - 0.5) * snowArea;
                const y = Math.random() * snowArea + 5;
                const z = (Math.random() - 0.5) * snowArea;
                
                snowPositions.push(x, y, z);
                
                snowVelocities.push(
                    (Math.random() - 0.5) * 0.015,
                    -0.35 * (0.5 + Math.random() * 0.5),
                    (Math.random() - 0.5) * 0.015
                );
            }
            
            // 10. ç”Ÿæˆåœ°é¢é›ªç²’å­
            console.log(`ç”Ÿæˆ${CONFIG.groundSnowParticleCount}ä¸ªåœ°é¢é›ªç²’å­...`);
            for (let i = 0; i < CONFIG.groundSnowParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.sqrt(Math.random()) * CONFIG.groundSnowRadius;
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const y = CONFIG.groundSnowHeight + (Math.random() - 0.5) * 0.4;
                
                groundSnowPositions.push(x, y, z);
            }
            
            // 11. ç”Ÿæˆæ˜Ÿæ˜Ÿæ•£è½ç›®æ ‡ä½ç½®ï¼ˆéšæœºæ•£è½åœ¨é›ªåœ°å‘¨å›´ï¼‰
            console.log("ç”Ÿæˆæ˜Ÿæ˜Ÿæ•£è½ç›®æ ‡ä½ç½®...");
            starFallPositions = [];
            starFallVelocities = [];
            
            for (let i = 0; i < CONFIG.starParticleCount; i++) {
                // éšæœºæ•£è½åœ¨é›ªåœ°å‘¨å›´
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * CONFIG.starScatterRadius;
                const height = CONFIG.groundSnowHeight + Math.random() * 0.5;
                
                starFallPositions.push(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                // éšæœºé€Ÿåº¦æ–¹å‘
                starFallVelocities.push(
                    (Math.random() - 0.5) * CONFIG.starFallSpeed,
                    -Math.random() * CONFIG.starFallSpeed * 0.8,
                    (Math.random() - 0.5) * CONFIG.starFallSpeed
                );
            }
            
            console.log("ç²’å­æ•°æ®ç”Ÿæˆå®Œæˆ");
        }
        
        // ==================== åˆ›å»ºç²’å­ç³»ç»Ÿ ====================
        function createParticleSystems() {
            // 1. åˆ›å»ºæ ‘å† ç²’å­ç³»ç»Ÿ
            crownGeometry = new THREE.BufferGeometry();
            crownGeometry.setAttribute('position', new THREE.Float32BufferAttribute(crownTreePositions, 3));
            crownGeometry.setAttribute('color', new THREE.Float32BufferAttribute(crownTreeColors, 3));
            
            crownMaterial = new THREE.PointsMaterial({
                size: CONFIG.crownParticleSize,
                transparent: true,
                opacity: 0.92,
                sizeAttenuation: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            crownParticles = new THREE.Points(crownGeometry, crownMaterial);
            scene.add(crownParticles);
            
            // 2. åˆ›å»ºæ ‘å¹²ç²’å­ç³»ç»Ÿ
            trunkGeometry = new THREE.BufferGeometry();
            trunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trunkTreePositions, 3));
            trunkGeometry.setAttribute('color', new THREE.Float32BufferAttribute(trunkTreeColors, 3));
            
            trunkMaterial = new THREE.PointsMaterial({
                size: CONFIG.trunkParticleSize,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            trunkParticles = new THREE.Points(trunkGeometry, trunkMaterial);
            scene.add(trunkParticles);
            
            // 3. åˆ›å»ºæ ‘æç²’å­ç³»ç»Ÿ
            branchGeometry = new THREE.BufferGeometry();
            branchGeometry.setAttribute('position', new THREE.Float32BufferAttribute(branchTreePositions, 3));
            branchGeometry.setAttribute('color', new THREE.Float32BufferAttribute(branchTreeColors, 3));
            
            branchMaterial = new THREE.PointsMaterial({
                size: CONFIG.branchParticleSize,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            branchParticles = new THREE.Points(branchGeometry, branchMaterial);
            scene.add(branchParticles);
            
            // 4. åˆ›å»ºæ˜Ÿæ˜Ÿç²’å­ç³»ç»Ÿ
            starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            
            starMaterial = new THREE.PointsMaterial({
                size: CONFIG.starSize,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            starParticles = new THREE.Points(starGeometry, starMaterial);
            scene.add(starParticles);
            
            // 5. åˆ›å»ºç©ºä¸­é›ªèŠ±ç²’å­ç³»ç»Ÿ
            snowGeometry = new THREE.BufferGeometry();
            snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
            
            snowMaterial = new THREE.PointsMaterial({
                color: CONFIG.snowColor,
                size: CONFIG.crownParticleSize * 1.2,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            
            // 6. åˆ›å»ºåœ°é¢é›ªç²’å­ç³»ç»Ÿ
            groundSnowGeometry = new THREE.BufferGeometry();
            groundSnowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(groundSnowPositions, 3));
            
            groundSnowMaterial = new THREE.PointsMaterial({
                color: CONFIG.groundSnowColor,
                size: CONFIG.groundSnowSize,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });
            
            groundSnowParticles = new THREE.Points(groundSnowGeometry, groundSnowMaterial);
            scene.add(groundSnowParticles);
        }
        
        // ==================== å¯åŠ¨æ˜Ÿæ˜Ÿæ•£è½åŠ¨ç”» ====================
        function startStarFall() {
            if (starFallActive) return;
            
            starFallActive = true;
            starFallStartTime = Date.now();
            
            console.log("å¼€å§‹æ˜Ÿæ˜Ÿæ•£è½åŠ¨ç”»...");
        }
        
        // ==================== é‡ç½®æ˜Ÿæ˜Ÿåˆ°æ ‘é¡¶ ====================
        function resetStarsToTreeTop() {
            const starPositionsArray = starGeometry.attributes.position.array;
            const starColorsArray = starGeometry.attributes.color.array;
            
            // é‡ç½®æ˜Ÿæ˜Ÿä½ç½®åˆ°åŸå§‹ä½ç½®
            for (let i = 0; i < starPositionsArray.length; i++) {
                starPositionsArray[i] = starOriginalPositions[i];
            }
            
            // é‡ç½®æ˜Ÿæ˜Ÿé¢œè‰²
            for (let i = 0; i < starColorsArray.length; i++) {
                starColorsArray[i] = starColors[i];
            }
            
            starGeometry.attributes.position.needsUpdate = true;
            starGeometry.attributes.color.needsUpdate = true;
            
            // æ¢å¤æ˜Ÿæ˜Ÿå¯è§æ€§å’Œé€æ˜åº¦
            starMaterial.opacity = 0.95;
            starParticles.visible = true;
            
            console.log("æ˜Ÿæ˜Ÿå·²é‡ç½®åˆ°æ ‘é¡¶");
        }
        
        // ==================== ä¸æ»‘å½¢çŠ¶åˆ‡æ¢ ====================
        function switchShape() {
            if (transitionInProgress) return;
            transitionInProgress = true;
            
            const modeText = document.getElementById('mode-text');
            modeText.textContent = isTree ? "æ­£åœ¨åˆ‡æ¢åˆ°çˆ±å¿ƒ..." : "æ­£åœ¨åˆ‡æ¢å›åœ£è¯æ ‘...";
            modeText.style.background = "rgba(255, 105, 180, 0.4)";
            
            // è·å–å½“å‰ç²’å­ä½ç½®å’Œé¢œè‰²
            const crownPositions = crownGeometry.attributes.position.array;
            const crownColors = crownGeometry.attributes.color.array;
            const trunkPositions = trunkGeometry.attributes.position.array;
            const trunkColors = trunkGeometry.attributes.color.array;
            const branchPositions = branchGeometry.attributes.position.array;
            const branchColors = branchGeometry.attributes.color.array;
            const starPositionsArray = starGeometry.attributes.position.array;
            const starColorsArray = starGeometry.attributes.color.array;
            
            // ç¡®å®šç›®æ ‡ä½ç½®å’Œé¢œè‰²
            const targetCrownPositions = isTree ? crownHeartPositions : crownTreePositions;
            const targetCrownColors = isTree ? crownHeartColors : crownTreeColors;
            const targetTrunkPositions = isTree ? trunkHeartPositions : trunkTreePositions;
            const targetTrunkColors = isTree ? trunkHeartColors : trunkTreeColors;
            const targetBranchPositions = isTree ? branchHeartPositions : branchTreePositions;
            const targetBranchColors = isTree ? branchHeartColors : branchTreeColors;
            
            // ä¿å­˜èµ·å§‹ä½ç½®å’Œé¢œè‰²
            const startCrownPositions = [...crownPositions];
            const startCrownColors = [...crownColors];
            const startTrunkPositions = [...trunkPositions];
            const startTrunkColors = [...trunkColors];
            const startBranchPositions = [...branchPositions];
            const startBranchColors = [...branchColors];
            
            const startTime = Date.now();
            const duration = CONFIG.transitionDuration;
            const colorDelay = CONFIG.colorTransitionDelay;
            
            // å¦‚æœæ˜¯åˆ‡æ¢åˆ°çˆ±å¿ƒï¼Œå¯åŠ¨æ˜Ÿæ˜Ÿæ•£è½
            if (isTree) {
                startStarFall();
            } else {
                // å¦‚æœæ˜¯åˆ‡æ¢å›åœ£è¯æ ‘ï¼Œé‡ç½®æ˜Ÿæ˜Ÿä½ç½®
                resetStarsToTreeTop();
            }
            
            // å¼€å§‹è¿‡æ¸¡åŠ¨ç”»
            function animateTransition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ä¸‰æ¬¡è´å¡å°”æ›²çº¿ç¼“åŠ¨å‡½æ•°
                const easeProgress = easeInOutCubic(progress);
                
                // è®¡ç®—é¢œè‰²è¿‡æ¸¡è¿›åº¦
                const colorProgress = Math.max(0, (elapsed - colorDelay) / (duration - colorDelay));
                const easeColorProgress = easeInOutCubic(Math.min(colorProgress, 1));
                
                // æ›´æ–°æ ‘å† ä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < crownPositions.length; i++) {
                    crownPositions[i] = startCrownPositions[i] + 
                        (targetCrownPositions[i] - startCrownPositions[i]) * easeProgress;
                    
                    if (i < targetCrownColors.length) {
                        crownColors[i] = startCrownColors[i] + 
                            (targetCrownColors[i] - startCrownColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°æ ‘å¹²ä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < trunkPositions.length; i++) {
                    trunkPositions[i] = startTrunkPositions[i] + 
                        (targetTrunkPositions[i] - startTrunkPositions[i]) * easeProgress;
                    
                    if (i < targetTrunkColors.length) {
                        trunkColors[i] = startTrunkColors[i] + 
                            (targetTrunkColors[i] - startTrunkColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°æ ‘æä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < branchPositions.length; i++) {
                    branchPositions[i] = startBranchPositions[i] + 
                        (targetBranchPositions[i] - startBranchPositions[i]) * easeProgress;
                    
                    if (i < targetBranchColors.length) {
                        branchColors[i] = startBranchColors[i] + 
                            (targetBranchColors[i] - startBranchColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°ç²’å­å¤§å°
                if (isTree) {
                    const sizeProgress = Math.min(elapsed / (duration * 0.7), 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize + 
                        (CONFIG.trunkParticleSize * 1.3 - CONFIG.trunkParticleSize) * sizeProgress;
                } else {
                    const sizeProgress = Math.min(elapsed / (duration * 0.5), 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize * 1.3 + 
                        (CONFIG.trunkParticleSize - CONFIG.trunkParticleSize * 1.3) * sizeProgress;
                }
                
                // æ ‡è®°éœ€è¦æ›´æ–°
                crownGeometry.attributes.position.needsUpdate = true;
                crownGeometry.attributes.color.needsUpdate = true;
                trunkGeometry.attributes.position.needsUpdate = true;
                trunkGeometry.attributes.color.needsUpdate = true;
                branchGeometry.attributes.position.needsUpdate = true;
                branchGeometry.attributes.color.needsUpdate = true;
                trunkMaterial.needsUpdate = true;
                
                if (progress < 1) {
                    requestAnimationFrame(animateTransition);
                } else {
                    // è¿‡æ¸¡å®Œæˆ
                    isTree = !isTree;
                    transitionInProgress = false;
                    
                    // æ›´æ–°UI
                    updateUI();
                    
                    // ç¡®ä¿æœ€ç»ˆçŠ¶æ€æ­£ç¡®
                    trunkMaterial.size = isTree ? CONFIG.trunkParticleSize : CONFIG.trunkParticleSize * 1.3;
                    
                    // å¦‚æœåˆ‡æ¢åˆ°çˆ±å¿ƒä¸”æ˜Ÿæ˜Ÿæ•£è½åŠ¨ç”»å®Œæˆï¼Œéšè—æ˜Ÿæ˜Ÿ
                    if (!isTree && !starFallActive) {
                        starParticles.visible = false;
                    }
                    
                    console.log(`åˆ‡æ¢å®Œæˆ: ${isTree ? 'åœ£è¯æ ‘' : 'çˆ±å¿ƒ'}æ¨¡å¼`);
                }
            }
            
            animateTransition();
        }
        
        // ==================== åˆ‡æ¢é›ªèŠ±æ˜¾ç¤º ====================
        function toggleSnow() {
            snowEnabled = !snowEnabled;
            snowParticles.visible = snowEnabled;
            
            const snowText = document.getElementById('snow-text');
            snowText.textContent = `é›ªèŠ±: ${snowEnabled ? 'å¼€å¯' : 'å…³é—­'}`;
            snowText.style.background = snowEnabled ? "rgba(173, 216, 230, 0.3)" : "rgba(255, 255, 255, 0.1)";
            snowText.style.color = snowEnabled ? "#add8e6" : "rgba(255, 255, 255, 0.5)";
            
            console.log(`é›ªèŠ±æ•ˆæœ: ${snowEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
        }
        
        // ==================== ç¼“åŠ¨å‡½æ•° ====================
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * CONFIG.floatSpeed;
            const starTime = Date.now() * CONFIG.starTwinkleSpeed;
            
            // å¤„ç†æ˜Ÿæ˜Ÿæ•£è½åŠ¨ç”»
            if (starFallActive) {
                const fallElapsed = Date.now() - starFallStartTime;
                const fallProgress = Math.min(fallElapsed / CONFIG.starFallDuration, 1);
                
                const starPositionsArray = starGeometry.attributes.position.array;
                const starColorsArray = starGeometry.attributes.color.array;
                
                for (let i = 0; i < starPositionsArray.length; i += 3) {
                    const idx = i / 3;
                    
                    if (fallProgress < 1) {
                        // æ•£è½åŠ¨ç”»ï¼šä»å½“å‰ä½ç½®å‘ç›®æ ‡ä½ç½®ç§»åŠ¨
                        const startX = starOriginalPositions[i];
                        const startY = starOriginalPositions[i + 1];
                        const startZ = starOriginalPositions[i + 2];
                        
                        const targetX = starFallPositions[i];
                        const targetY = starFallPositions[i + 1];
                        const targetZ = starFallPositions[i + 2];
                        
                        // æ·»åŠ ä¸€äº›æŠ›ç‰©çº¿æ•ˆæœ
                        const parabola = Math.sin(fallProgress * Math.PI) * 2.0;
                        
                        starPositionsArray[i] = startX + (targetX - startX) * fallProgress;
                        starPositionsArray[i + 1] = startY + (targetY - startY) * fallProgress - parabola;
                        starPositionsArray[i + 2] = startZ + (targetZ - startZ) * fallProgress;
                        
                        // é€æ¸å˜æš—
                        const colorIdx = idx * 3;
                        if (colorIdx < starColorsArray.length) {
                            const darken = 1 - fallProgress * 0.7;
                            starColorsArray[colorIdx] *= darken;
                            starColorsArray[colorIdx + 1] *= darken;
                            starColorsArray[colorIdx + 2] *= darken;
                        }
                    } else {
                        // åŠ¨ç”»å®Œæˆï¼Œè®¾ç½®åˆ°æœ€ç»ˆä½ç½®
                        starPositionsArray[i] = starFallPositions[i];
                        starPositionsArray[i + 1] = starFallPositions[i + 1];
                        starPositionsArray[i + 2] = starFallPositions[i + 2];
                    }
                }
                
                starGeometry.attributes.position.needsUpdate = true;
                starGeometry.attributes.color.needsUpdate = true;
                
                // é€æ¸å‡å°‘æ˜Ÿæ˜Ÿé€æ˜åº¦
                starMaterial.opacity = 0.95 * (1 - fallProgress);
                
                if (fallProgress >= 1) {
                    starFallActive = false;
                    console.log("æ˜Ÿæ˜Ÿæ•£è½åŠ¨ç”»å®Œæˆ");
                }
            }
            
            if (!transitionInProgress) {
                // æ ¹æ®å½“å‰æ¨¡å¼è°ƒæ•´æ—‹è½¬é€Ÿåº¦
                const rotationSpeed = CONFIG.rotationSpeed * (isTree ? 1.0 : 0.7);
                
                // æ•´ä½“æ—‹è½¬ï¼ˆå—é¼ æ ‡æ§åˆ¶ï¼‰
                crownParticles.rotation.y += rotationSpeed + mouseX * 0.0008;
                crownParticles.rotation.x = Math.sin(time) * 0.01 + mouseY * 0.02;
                
                // æ ‘å† ç²’å­æµ®åŠ¨æ•ˆæœ
                const crownPositions = crownGeometry.attributes.position.array;
                const originalCrown = isTree ? crownTreePositions : crownHeartPositions;
                
                for (let i = 0; i < crownPositions.length; i += 3) {
                    const idx = i / 3;
                    const float1 = Math.sin(time * 0.5 + idx * 0.01) * CONFIG.floatAmplitude;
                    const float2 = Math.cos(time * 0.3 + idx * 0.005) * CONFIG.floatAmplitude * 0.6;
                    
                    const heightFactor = originalCrown[i + 1] / 10 + 0.5;
                    
                    crownPositions[i] = originalCrown[i] + float1 * 0.07 * heightFactor + float2 * 0.03;
                    crownPositions[i + 1] = originalCrown[i + 1] + float1 * 0.6 * heightFactor;
                    crownPositions[i + 2] = originalCrown[i + 2] + float1 * 0.03 * heightFactor + float2 * 0.06;
                }
                
                crownGeometry.attributes.position.needsUpdate = true;
                
                // æ˜Ÿæ˜Ÿé—ªçƒæ•ˆæœï¼ˆä»…åœ¨åœ£è¯æ ‘æ¨¡å¼ä¸”æ²¡æœ‰æ•£è½æ—¶ï¼‰
                if (isTree && !starFallActive) {
                    const starPositionsArray = starGeometry.attributes.position.array;
                    
                    for (let i = 0; i < starPositionsArray.length; i += 3) {
                        const idx = i / 3;
                        const twinkle = Math.sin(starTime + idx * 0.5) * CONFIG.starTwinkleAmplitude * 0.03;
                        const twinkle2 = Math.cos(starTime * 0.7 + idx * 0.3) * CONFIG.starTwinkleAmplitude * 0.02;
                        
                        starPositionsArray[i] = starOriginalPositions[i] + twinkle;
                        starPositionsArray[i + 1] = starOriginalPositions[i + 1] + twinkle2;
                        starPositionsArray[i + 2] = starOriginalPositions[i + 2] + twinkle;
                    }
                    
                    starGeometry.attributes.position.needsUpdate = true;
                    
                    // æ˜Ÿæ˜Ÿè·Ÿéšæ—‹è½¬
                    starParticles.rotation.y = crownParticles.rotation.y * 0.5;
                    starParticles.rotation.x = crownParticles.rotation.x * 0.5;
                }
                
                // æ ‘å¹²å’Œæ ‘æè·Ÿéšæ—‹è½¬
                trunkParticles.rotation.y = crownParticles.rotation.y;
                trunkParticles.rotation.x = crownParticles.rotation.x;
                branchParticles.rotation.y = crownParticles.rotation.y;
                branchParticles.rotation.x = crownParticles.rotation.x;
            }
            
            // é›ªèŠ±åŠ¨ç”»
            if (snowEnabled && snowGeometry.attributes.position) {
                const snowPositionsArray = snowGeometry.attributes.position.array;
                const snowArea = 32;
                const resetHeight = snowArea + 5;
                
                for (let i = 0; i < snowPositionsArray.length; i += 3) {
                    const velocityIndex = i / 3 * 3;
                    
                    snowPositionsArray[i] += snowVelocities[velocityIndex];
                    snowPositionsArray[i + 1] += snowVelocities[velocityIndex + 1];
                    snowPositionsArray[i + 2] += snowVelocities[velocityIndex + 2];
                    
                    snowPositionsArray[i] += Math.sin(time + i) * 0.001;
                    snowPositionsArray[i + 2] += Math.cos(time + i) * 0.001;
                    
                    if (snowPositionsArray[i + 1] < CONFIG.groundSnowHeight + 1) {
                        snowPositionsArray[i] = (Math.random() - 0.5) * snowArea;
                        snowPositionsArray[i + 1] = resetHeight;
                        snowPositionsArray[i + 2] = (Math.random() - 0.5) * snowArea;
                    }
                }
                
                snowGeometry.attributes.position.needsUpdate = true;
            }
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }
        
        // ==================== æ›´æ–°ç•Œé¢ ====================
        function updateUI() {
            const title = document.querySelector('h1');
            const switchBtn = document.getElementById('btn-switch');
            const modeText = document.getElementById('mode-text');
            
            if (isTree) {
                title.innerHTML = 'âœ¨ ~(ï½¡â‰§3â‰¦)ï¾‰âŒ’â˜†å®å®çš„åœ£è¯æ ‘ âœ¨';
                if (switchBtn) switchBtn.textContent = 'åˆ‡æ¢ä¸ºçˆ±å¿ƒ';
                modeText.textContent = 'åœ£è¯æ ‘æ¨¡å¼';
                modeText.style.background = "rgba(255, 105, 180, 0.2)";
            } else {
                title.innerHTML = 'â¤ï¸ (à¹‘â€²á´—â€µà¹‘)ï¼© Láµ’áµ›áµ‰áµ§â‚’áµ¤â¤ â¤ï¸';
                if (switchBtn) switchBtn.textContent = 'åˆ‡æ¢ä¸ºåœ£è¯æ ‘';
                modeText.textContent = 'çˆ±å¿ƒæ¨¡å¼';
                modeText.style.background = "rgba(255, 182, 193, 0.3)";
            }
            
            updateParticleCount();
        }
        
        // ==================== æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º ====================
        function updateParticleCount() {
            const treeParticles = CONFIG.spiralTurns * CONFIG.particlesPerTurn + 
                                  CONFIG.trunkParticleCount + CONFIG.branchParticleCount;
            
            // åªåœ¨åœ£è¯æ ‘æ¨¡å¼è®¡ç®—æ˜Ÿæ˜Ÿç²’å­
            const starParticles = isTree && !starFallActive ? CONFIG.starParticleCount : 0;
            const snowParticles = snowEnabled ? CONFIG.snowParticleCount : 0;
            const totalParticles = treeParticles + starParticles + snowParticles + CONFIG.groundSnowParticleCount;
            
            document.getElementById('particle-count').textContent = `ç²’å­æ•°: ${totalParticles.toLocaleString()}`;
        }
        
        // ==================== è®¾ç½®äº¤äº’ ====================
        function setupInteractions() {
            // é¼ æ ‡æ‹–åŠ¨æ§åˆ¶
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mouseX = (e.movementX / window.innerWidth) * 3.0;
                    mouseY = (e.movementY / window.innerHeight) * 3.0;
                } else {
                    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                }
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // è§¦æ‘¸æ§åˆ¶
            let touchStartX = 0, touchStartY = 0;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    e.preventDefault();
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    
                    mouseX = (touchX - touchStartX) / window.innerWidth * 6;
                    mouseY = (touchY - touchStartY) / window.innerHeight * 6;
                    
                    touchStartX = touchX;
                    touchStartY = touchY;
                    
                    e.preventDefault();
                }
            }, { passive: false });
            
            // é”®ç›˜æ§åˆ¶
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyH' || e.code === 'Space') {
                    switchShape();
                }
                if (e.code === 'KeyS') {
                    toggleSnow();
                }
            });
            
            // ç‚¹å‡»åˆ‡æ¢å½¢çŠ¶ï¼ˆä»…åœ¨éè¿‡æ¸¡çŠ¶æ€ï¼‰
            renderer.domElement.addEventListener('click', (e) => {
                if (e.target === renderer.domElement && !transitionInProgress) {
                    switchShape();
                }
            });
            
            // ç§»åŠ¨ç«¯æŒ‰é’®
            const switchBtn = document.getElementById('btn-switch');
            const snowBtn = document.getElementById('btn-snow');
            
            if (switchBtn) {
                switchBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!transitionInProgress) switchShape();
                });
                
                switchBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (!transitionInProgress) switchShape();
                }, { passive: false });
            }
            
            if (snowBtn) {
                snowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleSnow();
                });
                
                snowBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    toggleSnow();
                }, { passive: false });
            }
            
            // åŒå‡»é‡ç½®è§†è§’
            renderer.domElement.addEventListener('dblclick', () => {
                camera.position.set(15, 11, 15);
                camera.lookAt(0, CONFIG.treeVerticalPosition + 3, 0);
                mouseX = 0;
                mouseY = 0;
            });
        }
        
        // ==================== çª—å£å¤§å°è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>



