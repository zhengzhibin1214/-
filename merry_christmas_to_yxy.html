<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å²³æ¬£å®œ(å®á´—å®)çš„åœ£è¯æ ‘ğŸ„</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #0a0015 100%);
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 105, 180, 0.3);
            border-radius: 50%;
            border-top-color: #ff69b4;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            padding: 10px;
            pointer-events: none;
        }
        h1 {
            color: #ff69b4;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.9);
        }
        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 100;
            display: none;
        }
        .mobile-btn {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(255, 105, 180, 0.6);
            transition: all 0.3s;
            font-weight: bold;
        }
        .mobile-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(255, 105, 180, 0.8);
        }
        #particle-count {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 10px;
        }
        #mode-indicator {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .mode-text {
            display: inline-block;
            background: rgba(255, 105, 180, 0.2);
            color: #ff69b4;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.5s;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="spinner"></div>
        <p style="color: #ff69b4; margin-top: 20px;">æ­£åœ¨å®šåˆ¶ä¸“å±åœ£è¯æ ‘â¤ï¸...</p>
    </div>

    <div id="container">
        <div id="ui">
            <h1>âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨</h1>
            <p class="instructions">ç‚¹å‡»æˆ–æŒ‰ H é”®åˆ‡æ¢çˆ±å¿ƒ | é¼ æ ‡/æ‰‹æŒ‡æ‹–åŠ¨æ—‹è½¬</p>
        </div>
        
        <div id="mode-indicator">
            <span class="mode-text" id="mode-text">åœ£è¯æ ‘æ¨¡å¼</span>
        </div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="btn-switch">åˆ‡æ¢ä¸ºçˆ±å¿ƒ</button>
        </div>
        
        <div id="particle-count">ç²’å­æ•°: 0</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            // ç²’å­æ•°é‡
            crownParticleCount: 1800,
            trunkParticleCount: 150,
            branchParticleCount: 200,
            
            // é¢œè‰²é…ç½®
            crownColor: 0xFF69B4,          // ç²‰è‰²
            trunkColor: 0x8B4513,          // æ·±æ£•è‰²
            branchColor: 0xA0522D,         // èµ­è‰²
            heartBaseColor: 0xFFB6C1,      // çˆ±å¿ƒåº•åº§é¢œè‰²ï¼ˆæµ…ç²‰è‰²ï¼‰
            
            // ç²’å­å¤§å°
            crownParticleSize: 0.065,
            trunkParticleSize: 0.085,
            branchParticleSize: 0.07,
            
            // åŠ¨ç”»
            rotationSpeed: 0.0015,
            floatAmplitude: 0.018,
            floatSpeed: 0.0006,
            
            // ä½ç½®è°ƒæ•´
            treeVerticalOffset: 0,         // åœ£è¯æ ‘ä½ç½®ï¼ˆåœ¨ä¸­å¿ƒï¼‰
            heartVerticalOffset: 0,        // çˆ±å¿ƒä½ç½®ï¼ˆåœ¨ä¸­å¿ƒï¼‰
            
            // åœ†å½¢åº•åº§é…ç½®
            baseRadius: 3.0,               // åº•åº§åŠå¾„
            baseHeight: -1.8,              // åº•åº§é«˜åº¦
            baseParticleSize: 0.08,        // åº•åº§ç²’å­å¤§å°
            
            // è¿‡æ¸¡é…ç½®
            transitionDuration: 2000,      // è¿‡æ¸¡æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
            colorTransitionDelay: 300      // é¢œè‰²è¿‡æ¸¡å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let crownParticles, trunkParticles, branchParticles;
        let crownGeometry, trunkGeometry, branchGeometry;
        let crownMaterial, trunkMaterial, branchMaterial;
        
        // ç²’å­ä½ç½®æ•°ç»„
        let crownTreePositions = [], crownHeartPositions = [];
        let trunkTreePositions = [], trunkHeartPositions = [];
        let branchTreePositions = [], branchHeartPositions = [];
        
        // é¢œè‰²æ•°ç»„
        let trunkTreeColors = [], trunkHeartColors = [];
        let branchTreeColors = [], branchHeartColors = [];
        
        let isTree = true;
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let transitionInProgress = false;
        
        // ==================== ä¸»åˆå§‹åŒ– ====================
        async function init() {
            const loadingScreen = document.getElementById('loading-screen');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'flex';
                document.querySelector('.instructions').textContent = 'ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ‡æ¢çˆ±å¿ƒ';
            }
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0015);
            
            // åˆ›å»ºç›¸æœº - è°ƒæ•´åˆ°æœ€ä½³è§†è§’
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 13;
            camera.position.y = 1;
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff69b4, 0.7);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // ç”Ÿæˆç²’å­æ•°æ®
            generateParticleData();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystems();
            
            // è®¾ç½®äº¤äº’
            setupInteractions();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 800);
            }, 1200);
            
            console.log('ğŸ„ ä¸æ»‘è¿‡æ¸¡åœ£è¯æ ‘åˆå§‹åŒ–å®Œæˆï¼');
        }
        
        // ==================== ç”Ÿæˆç²’å­æ•°æ® ====================
        function generateParticleData() {
            // æ¸…ç©ºæ•°ç»„
            crownTreePositions = []; crownHeartPositions = [];
            trunkTreePositions = []; trunkHeartPositions = [];
            branchTreePositions = []; branchHeartPositions = [];
            trunkTreeColors = []; trunkHeartColors = [];
            branchTreeColors = []; branchHeartColors = [];
            
            // 1. ç”Ÿæˆæ ‘å† ç²’å­ - åœ£è¯æ ‘å½¢çŠ¶
            console.log("ç”Ÿæˆåœ£è¯æ ‘ç²’å­...");
            const treeLayers = 5;
            for (let layer = 0; layer < treeLayers; layer++) {
                const layerParticles = Math.floor(CONFIG.crownParticleCount / treeLayers);
                const layerHeight = layer * 0.85;
                const layerRadius = 3.5 - layer * 0.5;
                
                for (let i = 0; i < layerParticles; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.sqrt(Math.random()) * layerRadius;
                    const effectiveRadius = radius * (1 - layer * 0.15);
                    const height = layerHeight + Math.random() * 0.6;
                    
                    crownTreePositions.push(
                        Math.cos(angle) * effectiveRadius,
                        height + CONFIG.treeVerticalOffset,
                        Math.sin(angle) * effectiveRadius
                    );
                }
            }
            
            // 2. ç”Ÿæˆæ ‘å† ç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆå®Œå…¨å±…ä¸­ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒç²’å­...");
            for (let i = 0; i < CONFIG.crownParticleCount; i++) {
                // ä½¿ç”¨æ›´ç²¾ç¡®çš„å¿ƒå½¢çº¿å…¬å¼
                const t = Math.random() * Math.PI * 2;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 1.8;
                
                // è°ƒæ•´çˆ±å¿ƒä½ç½®ï¼Œä½¿å…¶å®Œå…¨å±…ä¸­
                crownHeartPositions.push(
                    x * 0.05,
                    y * 0.05 + CONFIG.heartVerticalOffset + 0.5, // ä¸Šç§»ä¸€ç‚¹ï¼Œæ›´åŠ å±…ä¸­
                    z
                );
            }
            
            // 3. ç”Ÿæˆæ ‘å¹²ç²’å­ - åœ£è¯æ ‘å½¢çŠ¶
            console.log("ç”Ÿæˆæ ‘å¹²ç²’å­...");
            const trunkHeight = 4.0;
            const trunkBaseRadius = 0.8;
            
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                const height = -2.0 + (Math.random() * trunkHeight);
                const normalizedHeight = (height + 2.0) / trunkHeight;
                const radius = trunkBaseRadius * (1 - normalizedHeight * 0.5);
                const angle = Math.random() * Math.PI * 2;
                
                trunkTreePositions.push(
                    Math.cos(angle) * radius * 0.7,
                    height + CONFIG.treeVerticalOffset,
                    Math.sin(angle) * radius
                );
                
                // æ ‘å¹²é¢œè‰²ï¼ˆæ·±æ£•è‰²ï¼‰
                trunkTreeColors.push(
                    (CONFIG.trunkColor >> 16 & 255) / 255, // R
                    (CONFIG.trunkColor >> 8 & 255) / 255,  // G
                    (CONFIG.trunkColor & 255) / 255        // B
                );
            }
            
            // 4. ç”Ÿæˆæ ‘å¹²ç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆåœ†å½¢åº•åº§ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒåº•åº§ç²’å­...");
            for (let i = 0; i < CONFIG.trunkParticleCount; i++) {
                // ç”Ÿæˆåœ†å½¢åº•åº§ï¼ˆæ‰å¹³åœ†ç¯ï¼‰
                const angle = Math.random() * Math.PI * 2;
                const radius = CONFIG.baseRadius * (0.7 + Math.random() * 0.3); // åŠå¾„æœ‰äº›å˜åŒ–
                const y = CONFIG.baseHeight;
                
                trunkHeartPositions.push(
                    Math.cos(angle) * radius,
                    y + CONFIG.heartVerticalOffset,
                    Math.sin(angle) * radius
                );
                
                // åº•åº§é¢œè‰²ï¼ˆæµ…ç²‰è‰²ï¼Œé€æ¸è¿‡æ¸¡ï¼‰
                trunkHeartColors.push(
                    (CONFIG.heartBaseColor >> 16 & 255) / 255, // R
                    (CONFIG.heartBaseColor >> 8 & 255) / 255,  // G
                    (CONFIG.heartBaseColor & 255) / 255        // B
                );
            }
            
            // 5. ç”Ÿæˆæ ‘æç²’å­ - åœ£è¯æ ‘å½¢çŠ¶
            console.log("ç”Ÿæˆæ ‘æç²’å­...");
            const branchLayers = [0.2, 1.4, 2.6];
            const branchesPerLayer = 6;
            
            for (let layer = 0; layer < branchLayers.length; layer++) {
                const layerHeight = branchLayers[layer];
                
                for (let branch = 0; branch < branchesPerLayer; branch++) {
                    const angle = (branch / branchesPerLayer) * Math.PI * 2 + Math.random() * 0.3;
                    const branchLength = 1.0 + Math.random() * 1.2;
                    const particlesPerBranch = Math.floor(CONFIG.branchParticleCount / (branchLayers.length * branchesPerLayer));
                    
                    for (let p = 0; p < particlesPerBranch; p++) {
                        const t = Math.random();
                        const curve = Math.sin(t * Math.PI) * 0.25;
                        const radius = 0.5 + branchLength * t;
                        const height = layerHeight - t * 0.4 + curve;
                        const jitter = (Math.random() - 0.5) * 0.25;
                        
                        branchTreePositions.push(
                            Math.cos(angle + curve) * radius + jitter,
                            height + CONFIG.treeVerticalOffset,
                            Math.sin(angle + curve) * radius + jitter
                        );
                        
                        // æ ‘æé¢œè‰²ï¼ˆèµ­è‰²ï¼‰
                        branchTreeColors.push(
                            (CONFIG.branchColor >> 16 & 255) / 255,
                            (CONFIG.branchColor >> 8 & 255) / 255,
                            (CONFIG.branchColor & 255) / 255
                        );
                    }
                }
            }
            
            // 6. ç”Ÿæˆæ ‘æç²’å­ - çˆ±å¿ƒå½¢çŠ¶ï¼ˆå›´ç»•çˆ±å¿ƒçš„å°ç²’å­ï¼‰
            console.log("ç”Ÿæˆçˆ±å¿ƒè£…é¥°ç²’å­...");
            for (let i = 0; i < CONFIG.branchParticleCount; i++) {
                // å›´ç»•çˆ±å¿ƒåˆ†å¸ƒçš„è£…é¥°ç²’å­
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 2.0 + Math.random() * 1.5;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta) + 1.0;
                const z = radius * Math.cos(phi);
                
                branchHeartPositions.push(
                    x * 0.4,
                    y * 0.4 + CONFIG.heartVerticalOffset,
                    z * 0.4
                );
                
                // è£…é¥°ç²’å­é¢œè‰²ï¼ˆç²‰è‰²æ¸å˜ï¼‰
                const pinkValue = 0.7 + Math.random() * 0.3;
                branchHeartColors.push(
                    pinkValue,           // R
                    pinkValue * 0.5,     // G
                    pinkValue * 0.7      // B
                );
            }
            
            console.log("ç²’å­æ•°æ®ç”Ÿæˆå®Œæˆ");
        }
        
        // ==================== åˆ›å»ºç²’å­ç³»ç»Ÿ ====================
        function createParticleSystems() {
            // 1. åˆ›å»ºæ ‘å† ç²’å­ç³»ç»Ÿ
            crownGeometry = new THREE.BufferGeometry();
            crownGeometry.setAttribute('position', new THREE.Float32BufferAttribute(crownTreePositions, 3));
            
            crownMaterial = new THREE.PointsMaterial({
                color: CONFIG.crownColor,
                size: CONFIG.crownParticleSize,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            crownParticles = new THREE.Points(crownGeometry, crownMaterial);
            scene.add(crownParticles);
            
            // 2. åˆ›å»ºæ ‘å¹²ç²’å­ç³»ç»Ÿï¼ˆå¸¦é¢œè‰²å±æ€§ï¼‰
            trunkGeometry = new THREE.BufferGeometry();
            trunkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trunkTreePositions, 3));
            trunkGeometry.setAttribute('color', new THREE.Float32BufferAttribute(trunkTreeColors, 3));
            
            trunkMaterial = new THREE.PointsMaterial({
                size: CONFIG.trunkParticleSize,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                vertexColors: true // å¯ç”¨é¡¶ç‚¹é¢œè‰²
            });
            
            trunkParticles = new THREE.Points(trunkGeometry, trunkMaterial);
            scene.add(trunkParticles);
            
            // 3. åˆ›å»ºæ ‘æç²’å­ç³»ç»Ÿï¼ˆå¸¦é¢œè‰²å±æ€§ï¼‰
            branchGeometry = new THREE.BufferGeometry();
            branchGeometry.setAttribute('position', new THREE.Float32BufferAttribute(branchTreePositions, 3));
            branchGeometry.setAttribute('color', new THREE.Float32BufferAttribute(branchTreeColors, 3));
            
            branchMaterial = new THREE.PointsMaterial({
                size: CONFIG.branchParticleSize,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                vertexColors: true // å¯ç”¨é¡¶ç‚¹é¢œè‰²
            });
            
            branchParticles = new THREE.Points(branchGeometry, branchMaterial);
            scene.add(branchParticles);
        }
        
        // ==================== ä¸æ»‘å½¢çŠ¶åˆ‡æ¢ ====================
        function switchShape() {
            if (transitionInProgress) return;
            transitionInProgress = true;
            
            const modeText = document.getElementById('mode-text');
            modeText.textContent = isTree ? "æ­£åœ¨åˆ‡æ¢åˆ°çˆ±å¿ƒ..." : "æ­£åœ¨åˆ‡æ¢å›åœ£è¯æ ‘...";
            modeText.style.background = "rgba(255, 105, 180, 0.4)";
            
            // è·å–å½“å‰ç²’å­ä½ç½®å’Œé¢œè‰²
            const crownPositions = crownGeometry.attributes.position.array;
            const trunkPositions = trunkGeometry.attributes.position.array;
            const trunkColors = trunkGeometry.attributes.color.array;
            const branchPositions = branchGeometry.attributes.position.array;
            const branchColors = branchGeometry.attributes.color.array;
            
            // ç¡®å®šç›®æ ‡ä½ç½®å’Œé¢œè‰²
            const targetCrownPositions = isTree ? crownHeartPositions : crownTreePositions;
            const targetTrunkPositions = isTree ? trunkHeartPositions : trunkTreePositions;
            const targetTrunkColors = isTree ? trunkHeartColors : trunkTreeColors;
            const targetBranchPositions = isTree ? branchHeartPositions : branchTreePositions;
            const targetBranchColors = isTree ? branchHeartColors : branchTreeColors;
            
            // ä¿å­˜èµ·å§‹ä½ç½®å’Œé¢œè‰²
            const startCrownPositions = [...crownPositions];
            const startTrunkPositions = [...trunkPositions];
            const startTrunkColors = [...trunkColors];
            const startBranchPositions = [...branchPositions];
            const startBranchColors = [...branchColors];
            
            const startTime = Date.now();
            const duration = CONFIG.transitionDuration;
            const colorDelay = CONFIG.colorTransitionDelay;
            
            // å¼€å§‹è¿‡æ¸¡åŠ¨ç”»
            function animateTransition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ä¸‰æ¬¡è´å¡å°”æ›²çº¿ç¼“åŠ¨å‡½æ•°ï¼Œè®©è¿‡æ¸¡æ›´ä¸æ»‘
                const easeProgress = easeInOutCubic(progress);
                
                // è®¡ç®—é¢œè‰²è¿‡æ¸¡è¿›åº¦ï¼ˆå»¶è¿Ÿå¼€å§‹ï¼‰
                const colorProgress = Math.max(0, (elapsed - colorDelay) / (duration - colorDelay));
                const easeColorProgress = easeInOutCubic(Math.min(colorProgress, 1));
                
                // æ›´æ–°æ ‘å† ä½ç½®
                for (let i = 0; i < crownPositions.length; i++) {
                    crownPositions[i] = startCrownPositions[i] + 
                        (targetCrownPositions[i] - startCrownPositions[i]) * easeProgress;
                }
                
                // æ›´æ–°æ ‘å¹²ä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < trunkPositions.length; i++) {
                    // ä½ç½®è¿‡æ¸¡
                    trunkPositions[i] = startTrunkPositions[i] + 
                        (targetTrunkPositions[i] - startTrunkPositions[i]) * easeProgress;
                    
                    // é¢œè‰²è¿‡æ¸¡ï¼ˆå¦‚æœæœ‰ç›®æ ‡é¢œè‰²ï¼‰
                    if (i < targetTrunkColors.length) {
                        trunkColors[i] = startTrunkColors[i] + 
                            (targetTrunkColors[i] - startTrunkColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°æ ‘æä½ç½®å’Œé¢œè‰²
                for (let i = 0; i < branchPositions.length; i++) {
                    // ä½ç½®è¿‡æ¸¡
                    branchPositions[i] = startBranchPositions[i] + 
                        (targetBranchPositions[i] - startBranchPositions[i]) * easeProgress;
                    
                    // é¢œè‰²è¿‡æ¸¡ï¼ˆå¦‚æœæœ‰ç›®æ ‡é¢œè‰²ï¼‰
                    if (i < targetBranchColors.length) {
                        branchColors[i] = startBranchColors[i] + 
                            (targetBranchColors[i] - startBranchColors[i]) * easeColorProgress;
                    }
                }
                
                // æ›´æ–°ç²’å­å¤§å°ï¼ˆè®©åº•åº§ç²’å­ç¨å¾®å˜å¤§ï¼‰
                if (isTree) {
                    // åˆ‡æ¢åˆ°çˆ±å¿ƒæ—¶ï¼Œæ ‘å¹²ç²’å­å˜å¤§å½¢æˆåº•åº§
                    const sizeProgress = Math.min(elapsed / (duration * 0.8), 1);
                    trunkMaterial.size = CONFIG.trunkParticleSize + 
                        (CONFIG.baseParticleSize - CONFIG.trunkParticleSize) * sizeProgress;
                } else {
                    // åˆ‡æ¢å›åœ£è¯æ ‘æ—¶ï¼Œæ¢å¤åŸå¤§å°
                    const sizeProgress = Math.min(elapsed / (duration * 0.6), 1);
                    trunkMaterial.size = CONFIG.baseParticleSize + 
                        (CONFIG.trunkParticleSize - CONFIG.baseParticleSize) * sizeProgress;
                }
                
                // æ ‡è®°éœ€è¦æ›´æ–°
                crownGeometry.attributes.position.needsUpdate = true;
                trunkGeometry.attributes.position.needsUpdate = true;
                trunkGeometry.attributes.color.needsUpdate = true;
                branchGeometry.attributes.position.needsUpdate = true;
                branchGeometry.attributes.color.needsUpdate = true;
                trunkMaterial.needsUpdate = true;
                
                if (progress < 1) {
                    requestAnimationFrame(animateTransition);
                } else {
                    // è¿‡æ¸¡å®Œæˆ
                    isTree = !isTree;
                    transitionInProgress = false;
                    
                    // æ›´æ–°UI
                    updateUI();
                    
                    // ç¡®ä¿æœ€ç»ˆçŠ¶æ€æ­£ç¡®
                    trunkMaterial.size = isTree ? CONFIG.trunkParticleSize : CONFIG.baseParticleSize;
                    
                    console.log(`åˆ‡æ¢å®Œæˆ: ${isTree ? 'åœ£è¯æ ‘' : 'çˆ±å¿ƒ'}æ¨¡å¼`);
                }
            }
            
            animateTransition();
        }
        
        // ==================== ç¼“åŠ¨å‡½æ•° ====================
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * CONFIG.floatSpeed;
            
            if (!transitionInProgress) {
                // æ ¹æ®å½“å‰æ¨¡å¼è°ƒæ•´æ—‹è½¬é€Ÿåº¦
                const rotationSpeed = CONFIG.rotationSpeed * (isTree ? 1.0 : 0.8);
                
                // æ•´ä½“æ—‹è½¬ï¼ˆå—é¼ æ ‡æ§åˆ¶ï¼‰
                crownParticles.rotation.y += rotationSpeed + mouseX * 0.001;
                crownParticles.rotation.x = Math.sin(time) * 0.02 + mouseY * 0.03;
                
                // æ ‘å† ç²’å­æµ®åŠ¨æ•ˆæœ
                const crownPositions = crownGeometry.attributes.position.array;
                const originalCrown = isTree ? crownTreePositions : crownHeartPositions;
                
                for (let i = 0; i < crownPositions.length; i += 3) {
                    const idx = i / 3;
                    const float1 = Math.sin(time + idx * 0.04) * CONFIG.floatAmplitude;
                    const float2 = Math.cos(time * 0.6 + idx * 0.02) * CONFIG.floatAmplitude * 0.6;
                    
                    crownPositions[i] = originalCrown[i] + float1 * 0.2 + float2;
                    crownPositions[i + 1] = originalCrown[i + 1] + float1 * 0.8;
                    crownPositions[i + 2] = originalCrown[i + 2] + float1 * 0.15 + float2 * 0.3;
                }
                
                crownGeometry.attributes.position.needsUpdate = true;
                
                // æ ‘å¹²å’Œæ ‘æè·Ÿéšæ—‹è½¬
                trunkParticles.rotation.y = crownParticles.rotation.y;
                trunkParticles.rotation.x = crownParticles.rotation.x;
                branchParticles.rotation.y = crownParticles.rotation.y;
                branchParticles.rotation.x = crownParticles.rotation.x;
            }
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }
        
        // ==================== æ›´æ–°ç•Œé¢ ====================
        function updateUI() {
            const title = document.querySelector('h1');
            const btn = document.getElementById('btn-switch');
            const modeText = document.getElementById('mode-text');
            
            if (isTree) {
                title.innerHTML = 'âœ¨ å®å®çš„åœ£è¯æ ‘ âœ¨';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºçˆ±å¿ƒ';
                modeText.textContent = 'åœ£è¯æ ‘æ¨¡å¼';
                modeText.style.background = "rgba(255, 105, 180, 0.2)";
            } else {
                title.innerHTML = 'â¤ï¸ æˆ‘çˆ±ä½ å®å® â¤ï¸';
                if (btn) btn.textContent = 'åˆ‡æ¢ä¸ºåœ£è¯æ ‘';
                modeText.textContent = 'çˆ±å¿ƒæ¨¡å¼';
                modeText.style.background = "rgba(255, 182, 193, 0.3)";
            }
            
            updateParticleCount();
        }
        
        // ==================== æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º ====================
        function updateParticleCount() {
            const totalParticles = CONFIG.crownParticleCount + CONFIG.trunkParticleCount + CONFIG.branchParticleCount;
            document.getElementById('particle-count').textContent = `ç²’å­æ•°: ${totalParticles.toLocaleString()}`;
        }
        
        // ==================== è®¾ç½®äº¤äº’ ====================
        function setupInteractions() {
            // é¼ æ ‡æ‹–åŠ¨æ§åˆ¶
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mouseX = (e.movementX / window.innerWidth) * 5;
                    mouseY = (e.movementY / window.innerHeight) * 5;
                } else {
                    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                }
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // è§¦æ‘¸æ§åˆ¶
            let touchStartX = 0, touchStartY = 0;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    e.preventDefault();
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    
                    mouseX = (touchX - touchStartX) / window.innerWidth * 10;
                    mouseY = (touchY - touchStartY) / window.innerHeight * 10;
                    
                    touchStartX = touchX;
                    touchStartY = touchY;
                    
                    e.preventDefault();
                }
            }, { passive: false });
            
            // é”®ç›˜æ§åˆ¶
            window.addEventListener('keydown', (e) => {
                if (e.code === 'KeyH' || e.code === 'Space') {
                    switchShape();
                }
            });
            
            // ç‚¹å‡»åˆ‡æ¢ï¼ˆä»…åœ¨éè¿‡æ¸¡çŠ¶æ€ï¼‰
            renderer.domElement.addEventListener('click', (e) => {
                if (e.target === renderer.domElement && !transitionInProgress) {
                    switchShape();
                }
            });
            
            // ç§»åŠ¨ç«¯æŒ‰é’®
            const switchBtn = document.getElementById('btn-switch');
            if (switchBtn) {
                switchBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!transitionInProgress) switchShape();
                });
                
                switchBtn.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (!transitionInProgress) switchShape();
                }, { passive: false });
            }
            
            // åŒå‡»é‡ç½®è§†è§’
            renderer.domElement.addEventListener('dblclick', () => {
                camera.position.z = 13;
                camera.position.y = 1;
                camera.lookAt(0, 0, 0);
                mouseX = 0;
                mouseY = 0;
            });
        }
        
        // ==================== çª—å£å¤§å°è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>




