<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>终极浪漫圣诞树</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    .info {
      position: absolute; 
      top: 10px; 
      left: 50%; 
      transform: translateX(-50%);
      color: #fff; 
      font-family: Arial, sans-serif; 
      font-size: 14px;
      z-index: 999;
    }
    #playBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background: #ff6b81;
      color: #fff;
      border: none;
      border-radius: 5px;
      z-index: 999;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="info">Merry Christmas</div>
  <button id="playBtn">点击播放圣诞音乐</button>
  <audio id="christmasMusic" src="https://assets.mixkit.co/active_storage/sfx/2943/2943-preview.mp3" loop muted>
    你的浏览器不支持audio标签
  
  <script>
    // ========== 全局配置 ==========
    const treeHeight = 6;    // 圣诞树高度
    const treeRadius = 3;   // 圣诞树底部半径
    const layers = 20;      // 圣诞树分层数
    const particleCount = 6000; // 圣诞树粒子数（降低以保手机流畅）
    const snowCount = 150;   // 雪花粒子数
    const snowSpeed = 0.02;  // 雪花速度
    const heartCount = 50;   // 爱心粒子数
    const trailLength = 3;   // 粒子拖尾保留的历史帧数

    // ========== 1. 初始化Three.js核心 ==========
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ========== 2. 光照系统（环境光+聚光灯） ==========
    // 环境光：均匀照亮场景
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // 聚光灯：模拟舞台光，增强立体感
    const spotLight = new THREE.SpotLight(0xffffff, 1);
    spotLight.position.set(2, treeHeight / 2 + 1, 2); // 树顶侧上方
    spotLight.target = new THREE.Object3D(); // 照射目标
    spotLight.target.position.set(0, 0, 0);    // 指向圣诞树中心
    spotLight.angle = Math.PI / 6;   // 光束角度
    spotLight.penumbra = 0.3;        // 边缘柔化
    spotLight.castShadow = true;     // 启用阴影（需配合接收阴影）
    scene.add(spotLight);
    scene.add(spotLight.target);

    // ========== 3. 圣诞树粒子系统 ==========
    const treeGeometry = new THREE.BufferGeometry();
    const treePositions = new Float32Array(particleCount * 3);
    const treeColors = new Float32Array(particleCount * 3);

    const layerHeight = treeHeight / layers; 
    for (let i = 0; i < particleCount; i++) {
      const layer = Math.floor(Math.random() * layers); 
      const y = -treeHeight / 2 + layer * layerHeight;
      const radius = treeRadius * (1 - layer / layers);
      const angle = Math.random() * Math.PI * 2;

      treePositions[i * 3] = radius * Math.cos(angle);
      treePositions[i * 3 + 1] = y;
      treePositions[i * 3 + 2] = radius * Math.sin(angle);

      // 圣诞树粒子颜色（暖粉渐变）
      const r = 0.8 + Math.random() * 0.2;  
      const g = 0.2 + Math.random() * 0.2;  
      const b = 0.6 + Math.random() * 0.2;  
      treeColors[i * 3] = r;
      treeColors[i * 3 + 1] = g;
      treeColors[i * 3 + 2] = b;
    }
    treeGeometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
    treeGeometry.setAttribute('color', new THREE.BufferAttribute(treeColors, 3));

    const treeMaterial = new THREE.PointsMaterial({
      size: 2,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const treeParticles = new THREE.Points(treeGeometry, treeMaterial);
    scene.add(treeParticles);

    // ========== 4. 粒子拖尾特效（记录历史位置） ==========
    const trailParticleCount = particleCount * trailLength;
    const trailPositions = new Float32Array(trailParticleCount * 3);
    const trailColors = new Float32Array(trailParticleCount * 3);
    const trailGeometry = new THREE.BufferGeometry();
    trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));

    const trailMaterial = new THREE.PointsMaterial({
      size: 1.5,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      opacity: 0.6 // 拖尾透明度
    });
    const trailParticles = new THREE.Points(trailGeometry, trailMaterial);
    scene.add(trailParticles);

    // 记录每个粒子的历史位置
    const particleTrails = new Array(particleCount).fill(0).map(() => []);

    // ========== 5. 树顶星星 ==========
    const starGeometry = new THREE.BufferGeometry();
    const starPositions = new Float32Array(1 * 3);
    starPositions[0] = 0;
    starPositions[1] = treeHeight / 2 + 0.5;
    starPositions[2] = 0;
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

    const starMaterial = new THREE.PointsMaterial({
      size: 5,
      color: 0xffffff, 
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    const star = new THREE.Points(starGeometry, starMaterial);
    scene.add(star);

    // ========== 6. 雪花粒子系统 ==========
    const snowGeometry = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(snowCount * 3);
    const snowColors = new Float32Array(snowCount * 3);

    for (let i = 0; i < snowCount; i++) {
      const x = (Math.random() - 0.5) * 10;
      const y = 8 + Math.random() * 5; 
      const z = (Math.random() - 0.5) * 10;
      snowPositions[i * 3] = x;
      snowPositions[i * 3 + 1] = y;
      snowPositions[i * 3 + 2] = z;

      const r = 0.9 + Math.random() * 0.1;
      const g = 0.9 + Math.random() * 0.1;
      const b = 1.0;
      snowColors[i * 3] = r;
      snowColors[i * 3 + 1] = g;
      snowColors[i * 3 + 2] = b;
    }
    snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
    snowGeometry.setAttribute('color', new THREE.BufferAttribute(snowColors, 3));

    const snowMaterial = new THREE.PointsMaterial({
      size: 1.5,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
    scene.add(snowParticles);

    function updateSnow() {
      const snowPos = snowParticles.geometry.attributes.position.array;
      for (let i = 0; i < snowCount; i++) {
        const yIndex = i * 3 + 1;
        snowPos[yIndex] -= snowSpeed; 
        if (snowPos[yIndex] < -treeHeight / 2 - 2) {
          snowPos[yIndex] = 15;
          snowPos[i * 3] = (Math.random() - 0.5) * 10;
          snowPos[i * 3 + 2] = (Math.random() - 0.5) * 10;
        }
      }
      snowParticles.geometry.attributes.position.needsUpdate = true;
    }

    // ========== 7. 爱心粒子系统（Sprite贴图） ==========
    const heartTexture = new THREE.TextureLoader().load(
      'https://cdn-icons-png.flaticon.com/512/291/291704.png' // 爱心贴图（可替换）
    );
    const heartSprites = [];

    function createHeart() {
      const material = new THREE.SpriteMaterial({
        map: heartTexture,
        color: 0xff69b4, // 粉色叠加
        transparent: true
      });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(0.5, 0.5, 1); // 爱心大小
      // 随机分布在圣诞树周围
      const range = 5;
      sprite.position.set(
        (Math.random() - 0.5) * range,
        (Math.random() - 0.5) * range,
        (Math.random() - 0.5) * range
      );
      sprite.rotationSpeed = (Math.random() - 0.5) * 0.02; // 旋转速度
      scene.add(sprite);
      return sprite;
    }

    // 初始化爱心
    for (let i = 0; i < heartCount; i++) {
      heartSprites.push(createHeart());
    }

    function updateHearts() {
      heartSprites.forEach(sprite => {
        sprite.rotation += sprite.rotationSpeed; // 缓慢旋转
        // 正弦浮动模拟“飘”感
        sprite.position.y += Math.sin(Date.now() * 0.001 + sprite.position.x * 10) * 0.01;
      });
    }

    // ========== 8. 背景音乐与点击交互 ==========
    const audio = document.getElementById('christmasMusic');
    const playBtn = document.getElementById('playBtn');
    playBtn.addEventListener('click', () => {
      audio.play();
      playBtn.style.display = 'none';
    });

    renderer.domElement.addEventListener('click', () => {
      alert('Merry Christmas！愿你被爱包围～');
    });

    // ========== 9. 动画循环（核心驱动） ==========
    camera.position.z = 10;

    function animate() {
      requestAnimationFrame(animate);
      
      // 圣诞树旋转
      treeParticles.rotation.y += 0.001;

      // 更新粒子拖尾
      let trailIndex = 0;
      for (let i = 0; i < particleCount; i++) {
        const pos = treeParticles.geometry.attributes.position.array;
        const x = pos[i * 3];
        const y = pos[i * 3 + 1];
        const z = pos[i * 3 + 2];
        
        // 记录当前位置到轨迹数组
        particleTrails[i].unshift({ x, y, z }); 
        particleTrails[i] = particleTrails[i].slice(0, trailLength); // 保留N帧历史
        
        // 填充拖尾粒子的位置和渐淡颜色
        for (let j = 0; j < particleTrails[i].length; j++) {
          const p = particleTrails[i][j];
          trailPositions[trailIndex * 3] = p.x;
          trailPositions[trailIndex * 3 + 1] = p.y;
          trailPositions[trailIndex * 3 + 2] = p.z;
          
          // 颜色随历史帧数变淡（j越大越透明）
          const fade = 1 - j * 0.25;
          trailColors[trailIndex * 3] = treeColors[i * 3] * fade;
          trailColors[trailIndex * 3 + 1] = treeColors[i * 3 + 1] * fade;
          trailColors[trailIndex * 3 + 2] = treeColors[i * 3 + 2] * fade;
          trailIndex++;
        }
      }
      trailGeometry.attributes.position.needsUpdate = true;
      trailGeometry.attributes.color.needsUpdate = true;

      // 雪花与爱心更新
      updateSnow();
      updateHearts();

      // 渲染场景
      renderer.render(scene, camera);
    }
    animate();

    // ========== 10. 窗口适配 ==========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>